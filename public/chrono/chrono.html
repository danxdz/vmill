<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chrono Study - Drawer + Timeline Bars (Offline)</title>
  <style>
    :root{
      --bg:#0b0c10; --panel:#11131a; --panel2:#0d0f15; --border:#23252f;
      --text:#e8e8e8; --muted:rgba(232,232,232,.75); --muted2:rgba(232,232,232,.55);
      --accent:#4c73ff; --ok:#42d18b; --warn:#ffd37a; --danger:#ff4c6a;
      --accent-10:rgba(76,115,255,.10); --accent-18:rgba(76,115,255,.18);
      --accent-35:rgba(76,115,255,.35); --accent-55:rgba(76,115,255,.55);
      --accent-65:rgba(76,115,255,.65); --accent-75:rgba(76,115,255,.75);
      --accent-85:rgba(76,115,255,.85);
      --radius:16px; --ui-scale:1;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text); background:var(--bg);
    }
    *{box-sizing:border-box;}
    body{margin:0; zoom:var(--ui-scale);}
    header{
      padding:14px 16px; border-bottom:1px solid var(--border);
      position:sticky; top:0; background:rgba(11,12,16,.92); backdrop-filter: blur(10px);
      z-index:50; display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    h1{margin:0; font-size:18px;}
    .sub{display:none; color:var(--muted); font-size:13px;}
    .topRight{display:flex; align-items:center; gap:8px;}
    #toggleLeftPanelBtn{display:none;}
    #savePill{display:none;}

    /* ── Pro header ── */
    .hLeft{display:flex; align-items:center;}
    .hLogoWrap{display:flex; align-items:center; gap:10px;}
    .hLogoIcon{
      width:36px; height:36px; border-radius:10px; flex-shrink:0;
      background:var(--accent-18); border:1px solid var(--accent-35);
      display:flex; align-items:center; justify-content:center;
      font-size:18px;
    }
    .hLogoText{display:flex; flex-direction:column; gap:1px;}
    .hTitle{font-size:15px; font-weight:800; letter-spacing:.01em; line-height:1.2;}
    .hJobLabel{
      font-size:11px; color:var(--muted); line-height:1.2;
      max-width:260px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .hSavePill{
      font-size:11px; color:var(--ok); font-family:ui-monospace,monospace;
      opacity:0; transition:opacity .35s; white-space:nowrap; min-width:0;
    }
    .hSavePill.vis{opacity:1;}
    .hBtn{padding:8px 14px; font-size:13px; font-weight:600; border-radius:11px;}
    .hBtnConfig{display:flex; align-items:center; gap:6px;}
    .hBtnIcon{font-size:14px; line-height:1;}
    .hLangSel{width:auto; min-width:60px; padding:7px 8px;}
    .hVersion{
      font-size:10px; font-family:ui-monospace,monospace; letter-spacing:.05em;
      color:var(--muted2); border:1px solid var(--border); border-radius:999px;
      padding:3px 8px; white-space:nowrap;
    }

    /* ── Theme presets ── */
    .themePresetRow{display:flex; gap:6px; flex-wrap:wrap; margin-top:2px;}
    .tpBtn{
      display:flex; align-items:center; gap:6px;
      padding:5px 10px; border-radius:9px; font-size:12px; font-weight:600;
      border:1px solid var(--border); background:rgba(255,255,255,.03);
      cursor:pointer; color:var(--muted); transition:all .12s;
    }
    .tpBtn:hover{background:rgba(255,255,255,.07); color:var(--text);}
    .tpBtn.tpActive{border-color:var(--accent-55); background:var(--accent-10); color:var(--text);}
    .tpSwatch{
      width:13px; height:13px; border-radius:3px; flex-shrink:0;
      background:var(--c-bg,#0b0c10);
      border:2px solid var(--c-acc,#4c73ff);
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:4px 10px; border-radius:999px;
      border:1px solid var(--border); background:rgba(255,255,255,.03);
      font-size:12px; color:var(--muted); white-space:nowrap;
    }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}
    button{
      border:1px solid #2a2d3a; background:rgba(255,255,255,.04); color:var(--text);
      padding:10px 12px; border-radius:12px; cursor:pointer;
    }
    button:hover{filter:brightness(1.08);}
    button.primary{background:var(--accent-18); border-color:var(--accent-55);}
    button.danger{background:rgba(255,76,106,.14); border-color:rgba(255,76,106,.55);}
    button:disabled{opacity:.5; cursor:not-allowed;}
    .btnbar{display:flex; flex-wrap:wrap; gap:8px; align-items:center;}
    #panelTogglesRow{justify-content:center; gap:6px;}
    #panelTogglesRow .iconBtn{padding:6px 10px; font-size:12px;}
    .hr{height:1px; background:var(--border); margin:12px 0;}

    main{padding:16px; max-width:none; margin:0;}
    .layout{display:grid; gap:12px; grid-template-columns:1fr;}
    @media(min-width:1040px){ .layout{grid-template-columns:420px 1fr;} }
    #leftPanelSection{
      display:flex;
      flex-direction:column;
      max-height:calc(100dvh - 96px);
      overflow:hidden;
      align-self:start;
    }
    #stationsList{
      flex:1;
      min-height:0;
      overflow:auto;
      padding-right:2px;
    }
    body.sidebarHidden #leftPanelSection{display:none;}
    @media(min-width:1040px){ body.sidebarHidden .layout{grid-template-columns:1fr;} }

    .card{
      background:var(--panel); border:1px solid var(--border); border-radius:var(--radius);
      padding:14px; box-shadow:0 12px 30px rgba(0,0,0,.25);
    }
    .title{font-size:14px; margin:0 0 10px;}
    .small{font-size:12px; color:var(--muted);}
    .muted{color:var(--muted);}
    .row{display:grid; gap:10px; grid-template-columns:1fr;}
    .row2{display:grid; gap:10px; grid-template-columns:1fr 1fr;}
    .row3{display:grid; gap:10px; grid-template-columns:1fr 1fr 1fr;}
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px;}
    input,select,textarea{
      width:100%; padding:10px 10px; border-radius:12px;
      border:1px solid #2a2d3a; background:var(--panel2); color:var(--text);
      outline:none;
    }
    textarea{min-height:42px; resize:vertical;}

    /* Sidebar */
    .sidebarTop{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;}
    .searchRow{display:flex; gap:8px;}
    .searchRow input{flex:1;}
    .stationBlock{border:1px solid var(--border); border-radius:14px; padding:10px; background:rgba(255,255,255,.02);}
    .stationHeader{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px;}
    .stationName{font-weight:1000; font-size:13px;}
    .stationMeta{font-size:12px; color:var(--muted);}
    .iconBtn{padding:6px 8px; border-radius:10px; opacity:.9;}
    .iconBtn:hover{background:rgba(255,255,255,.06);}
    .iconBtn.iconOnly{
      min-width:30px;
      padding:6px 7px;
      text-align:center;
      font-size:13px;
      line-height:1;
    }
    .iconBtn.active{
      background:var(--accent-18);
      border-color:var(--accent-55);
      color:var(--text);
      opacity:1;
    }
    .videoActionBtns{display:flex; flex-wrap:wrap; gap:6px; margin-top:8px;}
    .videoActionBtn{padding:6px 10px; border-radius:999px; font-size:12px;}
    .videoActionBtn.active{outline:2px solid var(--accent-35);}
    #videoSeqBtn,#videoManualStartBtn,#videoManualEndBtn,#videoApplyBtn,#videoClearBtn{
      padding:7px 10px;
      border-radius:10px;
      font-size:12px;
      line-height:1;
      white-space:nowrap;
      width:auto;
      min-height:32px;
    }
    .videoNum{
      max-width:82px;
      padding:7px 8px;
      border-radius:10px;
      text-align:right;
      font-size:12px;
    }
    .videoAdjustBtns{
      display:flex;
      justify-content:flex-end;
      align-items:center;
      gap:6px;
      flex-wrap:nowrap;
      white-space:nowrap;
    }
    .videoMiniBtn{
      padding:6px 8px;
      border-radius:10px;
      font-size:12px;
      line-height:1;
      min-width:60px;
      white-space:nowrap;
    }
    .videoMiniBtn.danger{min-width:52px;}
    .videoMarkersTable th,.videoMarkersTable td{
      padding:8px 10px;
      font-size:12px;
      vertical-align:middle;
    }
    .videoMarkersBox{
      overflow:visible;
      max-height:none;
    }
    .videoLaneBars{
      margin-top:8px; border:1px solid var(--border); border-radius:12px; padding:8px;
      background:rgba(255,255,255,.02);
    }
    .videoLaneGrid{display:grid; grid-template-columns:88px 1fr; gap:6px 8px; align-items:center;}
    .videoLaneLabel{font-size:11px; color:var(--muted);}
    .videoLaneTrack{position:relative; height:20px; border-radius:10px; background:rgba(255,255,255,.05); overflow:hidden;}
    .videoSeg{
      position:absolute; top:3px; height:14px; border-radius:8px; opacity:.85; border:1px solid rgba(0,0,0,.2);
      min-width:2px;
      cursor:grab;
    }
    .videoSeg.machineBox{
      background:repeating-linear-gradient(-35deg, rgba(200,208,220,.35) 0 6px, rgba(130,138,150,.30) 6px 12px) !important;
      border:2px solid #33c6ff;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.25);
    }
    .videoSeg.withMachineOverlay .videoSegOverlay{
      position:absolute;
      left:0; right:0; top:0;
      height:38%;
      border-radius:7px 7px 0 0;
      background:repeating-linear-gradient(-35deg, rgba(190,198,212,.30) 0 5px, rgba(120,128,140,.28) 5px 10px);
      border-bottom:1px solid rgba(255,255,255,.25);
      pointer-events:none;
    }
    .videoSeg:active{cursor:grabbing;}
    .videoSeg.open{opacity:.55; border-style:dashed;}
    .videoSeg.editing{
      box-shadow:0 0 0 1px rgba(255,255,255,.65), inset 0 0 0 1px rgba(0,0,0,.2);
    }
    .videoSegHandle{
      position:absolute;
      top:1px;
      bottom:1px;
      width:8px;
      border-radius:6px;
      background:rgba(255,255,255,.45);
      display:none;
      cursor:ew-resize;
    }
    .videoSeg.editing .videoSegHandle{display:block;}
    .videoSegHandle.start{left:1px;}
    .videoSegHandle.end{right:1px;}
    .videoRuleBar{
      margin-top:6px;
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:8px;
    }
    .videoCmdRow{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:8px;
    }
    .videoCmdRow .pill{height:32px;}
    .videoMetaRow{
      margin-top:8px;
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:8px 12px;
    }
    .videoManualRow .pill{min-width:220px; justify-content:center;}
    .videoPlayhead{position:absolute; top:0; bottom:0; width:2px; background:rgba(255,255,255,.9);}
    .jobList{display:flex; flex-direction:column; gap:8px;}
    .jobItem{
      border:1px solid var(--border); border-radius:14px; padding:10px;
      background:rgba(255,255,255,.03); cursor:pointer;
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .jobItem.active{border-color:var(--accent-65); background:var(--accent-10);}
    .jobName{font-weight:1000; font-size:13px; margin-bottom:4px;}
    .jobMeta{font-size:12px; color:var(--muted); display:flex; gap:10px; flex-wrap:wrap;}
    .progressWrap{margin-top:8px; height:8px; border-radius:999px; background:rgba(255,255,255,.06); overflow:hidden; border:1px solid rgba(255,255,255,.08);}
    .progressBar{height:100%; width:0%; background:var(--accent-75);}
    .progressBar.good{background:rgba(66,209,139,.75);}
    .progressBar.warn{background:rgba(255,211,122,.75);}
    .tiny{font-size:11px; color:var(--muted2); margin-top:6px;}

    /* Timer */
    .timerGrid{display:grid; gap:12px; grid-template-columns:1fr;}
    @media(min-width:1040px){ .timerGrid{grid-template-columns:1.05fr .95fr; align-items:start;} }
    /* Make cycles panel span full width of the grid */
    #panelCyclesBlock{ grid-column: 1 / -1; }
    #panelDock{display:flex; flex-direction:column; gap:10px;}
    #panelDock.panelLayoutGrid{
      display:grid;
      grid-template-columns:repeat(var(--panel-grid-cols,2), minmax(320px,1fr));
      align-items:start;
    }
    @media(max-width:1280px){
      #panelDock.panelLayoutGrid{grid-template-columns:repeat(2, minmax(280px,1fr));}
    }
    @media(max-width:860px){
      #panelDock.panelLayoutGrid{grid-template-columns:1fr;}
    }
    .panelBlock{transition:transform .15s ease, box-shadow .15s ease, opacity .15s ease;}
    .panelBlock.dragging{
      opacity:.75;
      transform:scale(.99);
      box-shadow:0 18px 34px rgba(0,0,0,.35);
    }
    .panelHdr{cursor:grab;}
    .panelHdr:active{cursor:grabbing;}
    .panelBlock{display:block;}
    body.videoMode .timerGrid{grid-template-columns:1fr !important;}
    body.videoMode #videoEl{height:min(62vh,560px);}
    body.videoMode #videoCaptureWrap{margin-top:12px;}
    .elapsed{
      font-size:40px; font-weight:1100; letter-spacing:.6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    .bigbtn{
      width:100%; padding:16px 14px; border-radius:18px;
      font-size:18px; font-weight:1100;
    }

    .scrollBox{border:1px solid var(--border); border-radius:14px; overflow:auto;}
    .scrollBox.noScroll{overflow:visible; max-height:none;}
    table{width:100%; border-collapse:collapse;}
    th,td{padding:10px; border-bottom:1px solid var(--border); font-size:13px; text-align:left; vertical-align:top;}
    th{color:var(--muted); font-weight:650;}
    .timelineCard{position:relative;}
    .timelineBarEditor{
      position:absolute;
      min-width:280px;
      max-width:340px;
      background:var(--panel2);
      border:1px solid #2a2d3a;
      border-radius:12px;
      padding:10px;
      box-shadow:0 16px 40px rgba(0,0,0,.45);
      z-index:12;
      display:none;
    }
    .timelineBarEditor.show{display:block;}
    .timelineBarEditorHead{
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      margin-bottom:6px;
    }
    .timelineBarEditor .row3{grid-template-columns:1fr 1fr 1fr;}
    .timelineBarEditor input{padding:8px 8px; border-radius:10px;}
    .timelineBarEditor .btnbar{margin-top:8px;}
    .timelineBarEditor.draggable{cursor:move;}
    .timelineBarEditor.draggable input,
    .timelineBarEditor.draggable button,
    .timelineBarEditor.draggable select,
    .timelineBarEditor.draggable textarea,
    .timelineBarEditor.draggable label{cursor:auto;}
    .right{text-align:right;}

    /* Toolbar */
    .toolbar{
      display:flex; flex-wrap:wrap; gap:8px; align-items:center;
      padding:10px; border:1px solid var(--border); border-radius:14px;
      background:rgba(255,255,255,.02);
    }
    #panelTimelineBlock .toolbar{
      gap:6px;
      padding:8px;
      align-items:center;
    }
    #panelTimelineBlock .toolbar button{
      padding:6px 10px;
      border-radius:10px;
      font-size:12px;
      line-height:1.1;
    }
    #panelTimelineBlock .toolbar .seg button{
      padding:6px 10px;
      border-radius:0;
      border-right:1px solid var(--border);
    }
    #panelTimelineBlock .toolbar .seg button:last-child{border-right:0;}
    #panelTimelineBlock .toolbar .chip{
      padding:6px 9px;
      gap:6px;
      font-size:11px;
    }
    #panelTimelineBlock .toolbar .countChip{
      padding:6px 9px;
      font-size:11px;
    }
    #panelTimelineBlock .toolbar .miniSelect{
      padding:6px 9px;
      font-size:12px;
      border-radius:10px;
    }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      border:1px solid var(--border); background:rgba(255,255,255,.02);
      font-size:12px; color:var(--muted);
      user-select:none;
    }
    .checkbox{transform:translateY(1px);}
    .seg{
      display:flex; border:1px solid var(--border); border-radius:999px; overflow:hidden;
      background:rgba(255,255,255,.02);
    }
    .seg button{
      border:0; border-right:1px solid var(--border);
      padding:8px 12px; border-radius:0; background:transparent;
      font-size:12px; color:var(--muted);
    }
    .seg button:last-child{border-right:0;}
    .seg button.active{background:var(--accent-18); color:rgba(232,232,232,.92);}
    .miniSelect{width:auto; padding:8px 10px; border-radius:999px;}
    .countChip{
      padding:8px 10px; border-radius:999px;
      border:1px solid var(--border); background:rgba(255,255,255,.02);
      font-size:12px; color:var(--muted);
    }
    .cycleInlineDetail{
      border:1px solid var(--border);
      border-radius:12px;
      background:rgba(255,255,255,.03);
      padding:8px 10px;
      margin:2px 0 6px;
    }
    .cycleInlineHead{
      display:flex;
      flex-wrap:wrap;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      margin-bottom:6px;
    }
    .cycleInlineLaps{
      display:grid;
      gap:5px;
    }
    .cycleInlineLap{
      display:grid;
      grid-template-columns:36px 1fr auto auto;
      gap:8px;
      align-items:center;
      padding:4px 0;
      border-top:1px dashed rgba(255,255,255,.10);
    }
    .cycleInlineLap:first-child{border-top:0;}

    canvas{
      width:100%; height:460px;
      border:1px solid var(--border); border-radius:14px;
      background:rgba(255,255,255,.02);
    }
    .legend{display:flex; flex-wrap:wrap; gap:8px; margin-top:10px;}
    .legendItem{display:flex; align-items:center; gap:8px; font-size:12px; color:var(--muted);}
    .swatch{width:10px; height:10px; border-radius:3px; border:1px solid rgba(255,255,255,.15);}

    /* Canvas tooltip */
    #tlTooltip{
      position:fixed;
      background:rgba(13,15,21,.97);
      border:1px solid rgba(76,115,255,.45);
      border-radius:10px;
      padding:8px 12px;
      font-size:12px;
      pointer-events:none;
      z-index:200;
      display:none;
      box-shadow:0 8px 24px rgba(0,0,0,.5);
      max-width:240px;
      line-height:1.5;
    }
    #tlTooltip.show{display:block;}
    #tlTooltip .tt-el{font-weight:700; color:var(--text);}
    #tlTooltip .tt-val{color:var(--ok); font-family:ui-monospace,Menlo,monospace;}
    #tlTooltip .tt-row{color:var(--muted);}
    #tlTooltip .tt-outlier{color:var(--danger); font-size:11px; margin-top:2px;}

    /* Toolbar groups */
    .toolbarGroup{
      display:flex; align-items:center; gap:6px; flex-wrap:wrap;
    }
    .toolbarDivider{
      width:1px; height:22px; background:var(--border);
      flex-shrink:0;
      align-self:center;
    }
    .toolbarLabel{
      font-size:10px; text-transform:uppercase; letter-spacing:.06em;
      color:var(--muted2); white-space:nowrap; padding:0 2px;
    }

    /* Drawer (right) */
    .drawerOverlay{
      position:fixed; inset:0; background:rgba(0,0,0,.45);
      opacity:0; pointer-events:none; transition:opacity .18s ease;
      z-index:80;
    }
    .drawer{
      position:fixed; top:0; right:0; height:100dvh; width:min(520px, 92vw);
      background:rgba(17,19,26,.98);
      border-left:1px solid var(--border);
      transform:translateX(105%); transition:transform .22s ease;
      z-index:90; display:flex; flex-direction:column;
    }
    .drawerHeader{
      padding:14px 14px; border-bottom:1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .drawerTitle{font-weight:1000;}
    .drawerBody{padding:14px; overflow:auto;}
    .drawerSection{
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(255,255,255,.02);
      margin-bottom:10px;
      overflow:hidden;
    }
    .drawerSecBtn{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      border:0;
      border-bottom:1px solid rgba(255,255,255,.06);
      border-radius:0;
      padding:10px 12px;
      background:rgba(255,255,255,.03);
      text-align:left;
    }
    .drawerSecBtn .title{margin:0; font-size:14px;}
    .drawerBurgerIcon{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:22px; height:22px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.04);
      font-size:12px;
      line-height:1;
      color:var(--muted);
      flex:0 0 auto;
    }
    .drawerSecChevron{
      color:var(--muted2);
      font-size:12px;
      transition:transform .15s ease;
      flex:0 0 auto;
    }
    .drawerSection.collapsed .drawerSecChevron{transform:rotate(-90deg);}
    .drawerSecBody{padding:12px;}
    .drawerSection.collapsed .drawerSecBody{display:none;}
    .drawerSection:last-child{margin-bottom:0;}
    .open .drawerOverlay{opacity:1; pointer-events:auto;}
    .open .drawer{transform:translateX(0);}

    /* ── Panel collapse headers ── */
    .panelHdr{
      width:100%; display:flex; align-items:center; justify-content:space-between; gap:8px;
      padding:10px 0 6px; border:0; background:transparent; color:var(--text);
      cursor:pointer; text-align:left; border-bottom:1px solid var(--border); margin-bottom:10px;
    }
    .panelHdr:hover{ opacity:.85; }
    .panelHdrTitle{ font-size:14px; font-weight:700; }
    .panelHdrChevron{
      color:var(--muted2); font-size:16px; line-height:1;
      transition:transform .18s ease; display:inline-block; transform:rotate(90deg);
    }
    .panelBlock.collapsed .panelHdrChevron{ transform:rotate(0deg); }
    .panelBlock.collapsed .panelHdrBody{ display:none; }

    /* ── Header panel toggles row ── */
    .hPanelToggles{ display:flex; gap:4px; align-items:center; flex-wrap:wrap; }
    .hPanelBtn{ padding:5px 9px; font-size:11px; border-radius:8px; }
    .hDivider{ width:1px; height:22px; background:var(--border); flex-shrink:0; }
    .hBtnCamera{
      font-size:16px; padding:7px 10px; border-radius:10px; text-decoration:none;
      display:inline-flex; align-items:center; justify-content:center;
      color:var(--text); border:1px solid var(--border); background:rgba(255,255,255,.04);
    }
    .hBtnCamera:hover{ filter:brightness(1.12); }

    /* ── Light-theme adaptive borders / inputs ── */
    body.themeLight input, body.themeLight select, body.themeLight textarea{
      border-color:rgba(0,0,0,.18);
    }
    body.themeLight button:not(.primary):not(.danger){
      border-color:rgba(0,0,0,.14); background:rgba(0,0,0,.04); color:var(--text);
    }
    body.themeLight .card{ box-shadow:0 2px 12px rgba(0,0,0,.08); }
    body.themeLight .stationBlock{ background:rgba(0,0,0,.03); }
    body.themeLight .jobItem{ background:rgba(0,0,0,.03); }
    body.themeLight .scrollBox{ border-color:rgba(0,0,0,.12); }
    body.themeLight th{ color:rgba(0,0,0,.55); }
    body.themeLight td{ border-bottom-color:rgba(0,0,0,.08); }
    body.themeLight .muted, body.themeLight .small{ color:rgba(0,0,0,.55); }
    body.themeLight .toolbarLabel{ color:rgba(0,0,0,.4); }
    body.themeLight .panelHdr{ border-bottom-color:rgba(0,0,0,.12); }
    body.themeLight .hr{ background:rgba(0,0,0,.10); }

    body.themeLight {
      --bg: #f0f2f5;
      --panel: #ffffff;
      --panel2: #f8f9fa;
      --border: #d1d5db;
      --text: #111827;
      --muted: #4b5563;
      --muted2: #9ca3af;
      --accent-10: rgba(76, 115, 255, 0.08);
      --accent-18: rgba(76, 115, 255, 0.15);
    }
    body.themeLight header { background: rgba(240, 242, 245, 0.92); }

    #leftPanelSection .panelHdr{padding-top:2px; margin-bottom:8px;}
    #leftPanelSection .panelHdrBody{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
      flex:1;
    }

    .timelineFilterSelect{min-width:170px; max-width:260px;}

    .panelHdr[draggable="true"]{cursor:grab;}
    .panelHdr[draggable="true"]:active{cursor:grabbing;}
    .panelHdr.dropBefore{box-shadow:inset 0 2px 0 var(--accent);}

    @media(max-width:1039px){
      header{padding:10px 12px; gap:8px; flex-wrap:wrap; align-items:flex-start;}
      .topRight{width:100%; justify-content:center; flex-wrap:wrap; gap:8px;}
      main{padding:10px;}
      .layout{grid-template-columns:1fr !important;}
      #leftPanelSection, #rightMainSection{width:100%; margin:0 auto; max-width:980px;}
      .sidebarTop{align-items:flex-start;}
      .sidebarTop .btnbar{justify-content:flex-end;}
      .toolbar{justify-content:center;}
      .btnbar{justify-content:center;}
      #panelTogglesRow{justify-content:center;}
      .row2, .row3{grid-template-columns:1fr;}
    }
  </style>
</head>
<body>
<div id="tlTooltip"></div>
<header>
  <div class="hLeft">
    <div class="hLogoWrap">
      <span class="hLogoIcon">⏱</span>
      <div class="hLogoText">
        <span class="hTitle">Chrono Study</span>
        <span class="hJobLabel" id="hJobLabel">—</span>
      </div>
    </div>
  </div>
  <div class="topRight">
    <span class="hSavePill" id="savePill"></span>
    <select id="quickPanelLayoutSel" class="miniSelect hLangSel" title="Panel layout">
      <option value="stack">Stack</option>
      <option value="grid">Grid</option>
    </select>
    <!-- Panel visibility toggles -->
    <div class="hPanelToggles" id="panelTogglesRow">
      <button class="iconBtn hPanelBtn active" type="button" data-panel-toggle="jobs" title="Show/Hide jobs panel">Jobs</button>
      <button class="iconBtn hPanelBtn active" type="button" data-panel-toggle="timer" title="Click hide/show · Drag to reorder">Timer</button>
      <button class="iconBtn hPanelBtn active" type="button" data-panel-toggle="kpi" title="Click hide/show · Drag to reorder">KPI</button>
      <button class="iconBtn hPanelBtn active" type="button" data-panel-toggle="timeline" title="Click hide/show · Drag to reorder">Timeline</button>
      <button class="iconBtn hPanelBtn active" type="button" data-panel-toggle="cycles" title="Click hide/show · Drag to reorder">Cycles</button>
    </div>
    <div class="hDivider"></div>
    <a id="openCameraBtn" class="iconBtn hBtn hBtnCamera" href="chrono_camera.html" target="_blank" title="Open Camera module">📷</a>
    <button id="toggleLeftPanelBtn" class="iconBtn hBtn" title="Show/Hide jobs panel" style="display:none;">Jobs</button>
    <button id="openDrawerBtn" class="primary hBtn hBtnConfig" title="Open configuration">
      <span class="hBtnIcon">⚙</span><span id="hConfigLabel">Config</span>
    </button>
    <select id="langSelect" class="miniSelect hLangSel" title="Language"></select>
    <span class="hVersion">v5</span>
  </div>
</header>

<main class="layout">
  <!-- LEFT: stations/jobs list always visible -->
  <section class="card panelBlock" id="leftPanelSection">
    <button class="panelHdr" data-panel-hdr="jobsSidebar">
      <span class="panelHdrTitle">Stations & Jobs</span>
      <span class="panelHdrChevron">›</span>
    </button>
    <div class="panelHdrBody">
    <div class="sidebarTop">
      <div class="btnbar" style="gap:6px;">
        <button class="primary" id="newStationBtn">+ Station</button>
      </div>
    </div>

    <div class="searchRow">
      <input id="searchBox" placeholder="Search station/job..." />
      <button id="clearSearchBtn">Clear</button>
    </div>

    <div class="hr"></div>
    <div id="stationsList" class="row" style="gap:10px;"></div>
    </div>
  </section>

  <!-- RIGHT: timer + graph + cycles (config moved to drawer) -->
  <section class="card" id="rightMainSection">
    <div class="hr"></div>

    <div id="panelDock">
      <div class="panelBlock" id="panelTimerBlock">
      <button class="panelHdr" data-panel-hdr="timer">
        <span class="panelHdrTitle">Timer</span>
        <div style="display:flex;align-items:center;gap:8px;">
          <span class="small muted" id="jobHeader">Select a job</span>
          <span class="panelHdrChevron">›</span>
        </div>
      </button>
      <div class="panelHdrBody">
      <div class="card" id="panelTimerCard" style="padding:12px; border-radius:14px;">
        <div class="small muted">Current elapsed</div>
        <div class="elapsed" id="elapsed">00:00.000</div>

        <div class="hr"></div>

        <div style="display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap;">
          <div>
            <div class="small muted">Current element</div>
            <div style="font-size:22px; font-weight:1100;" id="curElName">-</div>
            <div class="small" id="curElType">-</div>
          </div>
          <div>
            <div class="small muted">Index</div>
            <div class="mono" style="font-size:16px; font-weight:1100;" id="curIndex">-</div>
            <div class="small muted" id="curHint">Press Start</div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row2">
          <div>
            <label>Capture mode</label>
            <select id="captureModeSel">
              <option value="continuous">Continuous sequence</option>
              <option value="single">Single action repeat</option>
              <option value="video">Video capture</option>
            </select>
          </div>
          <div id="singleActionWrap">
            <label>Single action</label>
            <select id="singleActionSel"></select>
          </div>
        </div>

        <div id="videoCaptureWrap" style="display:none; margin-top:10px;">
          <div class="row2">
            <div>
              <label>Video file</label>
              <input id="videoFile" type="file" accept="video/*" />
            </div>
            <div>
              <label>Recorded videos + bookmarks</label>
              <select id="videoLibSel">
                <option value="">(none)</option>
              </select>
            </div>
          </div>
          <div class="videoCmdRow" style="margin-top:8px;">
            <button id="videoLibLoadBtn" type="button">Load bookmarks</button>
            <button id="videoLibDeleteBtn" class="danger" type="button">Delete entry</button>
            <button id="videoLibRefreshBtn" type="button">Refresh list</button>
          </div>
          <div style="margin-top:8px;">
            <video id="videoEl" controls style="width:100%; border:1px solid var(--border); border-radius:12px; background:#000;"></video>
          </div>
          <div style="margin-top:8px;">
            <label>Video timeline</label>
            <input id="videoTimeline" type="range" min="0" max="0" step="0.001" value="0" />
            <div class="small muted mono" id="videoTimelineLabel">00:00.000 / 00:00.000</div>
            <div id="videoLaneBars" class="videoLaneBars"></div>
            <div id="videoActionBtns" class="videoActionBtns"></div>
          </div>
          <div class="videoCmdRow">
            <button id="videoSeqBtn" class="primary" type="button">Play + Next</button>
            <button id="videoApplyBtn" type="button">Create cycle from markers</button>
            <button id="videoClearBtn" class="danger" type="button">Clear markers</button>
          </div>
          <div class="videoCmdRow videoManualRow">
            <button id="videoManualStartBtn" type="button">Mark start</button>
            <div class="pill mono" id="videoActionText">-</div>
            <button id="videoManualEndBtn" type="button">Mark end</button>
          </div>
          <div class="videoMetaRow">
            <label class="chip"><input class="checkbox" id="videoStackRulesChk" type="checkbox" checked /> Auto stack by rules</label>
            <button id="videoAutoStackBtn" type="button">Apply stack</button>
            <span class="small muted mono" id="videoWaitInfo">Wait: 00:00.000</span>
          </div>
          <div class="small muted" id="videoMarkersList">No markers</div>
        </div>

        <div class="hr"></div>

        <button class="primary bigbtn" id="mainBtn" disabled>Start</button>

        <div class="btnbar" id="timerActionBar" style="margin-top:10px;">
          <button id="finishCycleBtn" disabled>Finish cycle</button>
          <button id="undoBtn" disabled>Undo</button>
          <button class="danger" id="clearJobCyclesBtn">Clear cycles</button>
        </div>

        <div class="small muted" id="timerKeyboardHint" style="margin-top:10px;">
          Space = Start/Next/Finish - Backspace = Undo
        </div>
      </div>
      </div><!-- /panelHdrBody timer -->
      </div>

      <div class="panelBlock" id="panelKpiBlock">
      <button class="panelHdr" data-panel-hdr="kpi">
        <span class="panelHdrTitle">KPI</span>
        <span class="panelHdrChevron">›</span>
      </button>
      <div class="panelHdrBody">
      <div class="card" id="panelKpiCard" style="padding:12px; border-radius:14px;">
        <div class="row">
          <div class="pill">Cycles <span class="mono" id="cyclesCount">0</span></div>
          <div class="pill">Std time <span class="mono" id="stdTotal">-</span></div>
          <div class="small" id="stdExplain">Record cycles to compute.</div>
          <div class="pill">Stability <span id="stabilityText">No data</span></div>
        </div>
        <div class="row3" style="margin-top:8px;">
          <div class="pill">Avg obs <span class="mono" id="avgCycleObs">-</span></div>
          <div class="pill">Median <span class="mono" id="medianCycle">-</span></div>
          <div class="pill">P90 <span class="mono" id="p90Cycle">-</span></div>
        </div>
        <div class="row3" style="margin-top:8px;">
          <div class="pill">Best / Worst <span class="mono" id="bestWorstCycle">-</span></div>
          <div class="pill">CV <span class="mono" id="cvCycle">-</span></div>
          <div class="pill">Throughput <span class="mono" id="throughputCycle">-</span></div>
        </div>
        <div class="btnbar" id="kpiReportBtns" style="margin-top:8px;">
          <button id="kpiExportCsvBtn" type="button">Export CSV</button>
          <button id="kpiPrintBtn" type="button">🖨 Print / PDF</button>
        </div>
        <div class="small muted" style="margin-top:10px;">Action average times (selected tag filter)</div>
        <div class="scrollBox noScroll" style="margin-top:6px;">
          <table>
            <thead>
              <tr>
                <th>Action</th>
                <th class="right">Avg</th>
                <th class="right">Min</th>
                <th class="right">Max</th>
                <th class="right">Share</th>
              </tr>
            </thead>
            <tbody id="kpiActionBody"></tbody>
          </table>
        </div>
      </div>
      </div><!-- /panelHdrBody kpi -->
      </div>

    <div id="panelTimelineBlock" class="panelBlock">
      <button class="panelHdr" data-panel-hdr="timeline">
        <span class="panelHdrTitle">Timeline</span>
        <div style="display:flex;align-items:center;gap:8px;">
          <span class="countChip" id="cyclesShownChip" title="Cycles shown after tag filter">0 cycles</span>
          <span class="panelHdrChevron">›</span>
        </div>
      </button>
      <div class="panelHdrBody">

      <div class="toolbar" style="flex-direction:column; align-items:stretch; gap:8px;">

        <!-- Row 1: View mode + display options -->
        <div class="toolbarGroup">
          <span class="toolbarLabel">View</span>
          <div class="seg" title="Selected: show only checked cycles (max 6 lines). All: show every cycle stacked.">
            <button id="modeSelectedBtn" class="active" type="button">Selected cycles</button>
            <button id="modeAllBtn" type="button">All cycles</button>
          </div>
          <div class="toolbarDivider"></div>
          <span class="toolbarLabel">Show</span>
          <label class="chip" title="Draw a dashed line at the average time boundary for each element">
            <input class="checkbox" id="showAvgLineChk" type="checkbox" checked /> Avg markers
          </label>
          <label class="chip" title="Highlight bars that exceed the outlier threshold with a red outline">
            <input class="checkbox" id="showOutliersChk" type="checkbox" checked /> Outliers
          </label>
          <select id="outlierModeSel" class="miniSelect" title="Outlier detection method: 1.5× average or IQR box-plot method">
            <option value="MULT_1_5">&gt; 1.5× avg</option>
            <option value="IQR">IQR</option>
          </select>
        </div>

        <!-- Row 2: Scope selectors -->
        <div class="toolbarGroup">
          <span class="toolbarLabel">Scope</span>
          <select id="timelineStationSel" class="miniSelect timelineFilterSelect" title="Switch active station for timeline"></select>
          <select id="timelineJobSel" class="miniSelect timelineFilterSelect" title="Switch active job for timeline"></select>
        </div>

        <!-- Row 3: Tag filters -->
        <div class="toolbarGroup">
          <span class="toolbarLabel">Tags</span>
          <label class="chip" title="Include Normal cycles"><input class="checkbox" id="tagNormal" type="checkbox" checked /> Normal</label>
          <label class="chip" title="Include Rework cycles"><input class="checkbox" id="tagRework" type="checkbox" checked /> Rework</label>
          <label class="chip" title="Include Training cycles"><input class="checkbox" id="tagTraining" type="checkbox" checked /> Training</label>
          <label class="chip" title="Include Disturbance cycles"><input class="checkbox" id="tagDisturbance" type="checkbox" checked /> Disturbance</label>
        </div>

        <!-- Row 4: Cycle selection (only relevant in Selected mode) -->
        <div class="toolbarGroup" id="selectionToolbar">
          <span class="toolbarLabel">Select</span>
          <button id="selectLast3Btn" type="button" title="Select the 3 most recent cycles">Last 3</button>
          <button id="selectAllCyclesForLineBtn" type="button" title="Select all visible cycles for the graph (no cap)">All visible</button>
          <button id="clearSelectionBtn" type="button" title="Deselect all cycles">Clear</button>
          <span id="selCountChip" class="countChip" title="Number of cycles currently selected for the graph" style="min-width:0;">0 sel.</span>
        </div>

      </div>

      <div class="small muted" id="timelineEditHint" style="margin-top:8px;">
        💡 Hover bar for details · Drag to move · Drag right edge to resize · Click to edit precise values
      </div>

      <div id="timelineChartCard" class="card timelineCard" style="padding:12px; border-radius:14px; margin-top:10px;">
        <canvas id="timelineChart" width="1100" height="520" style="width:100%; height:auto; cursor:default;"></canvas>
        <div id="timelineBarEditor" class="timelineBarEditor">
          <div class="timelineBarEditorHead">
            <strong id="tlEdTitle">Action</strong>
            <button id="tlEdCloseBtn" class="iconBtn iconOnly" type="button" style="font-size:16px;">×</button>
          </div>
          <div class="small muted mono" id="tlEdMeta">-</div>
          <div class="row3" style="margin-top:8px;">
            <div>
              <label>Start s</label>
              <input id="tlEdStart" type="number" step="0.001" min="0" />
            </div>
            <div>
              <label>Dur s</label>
              <input id="tlEdDur" type="number" step="0.001" min="0" />
            </div>
            <div>
              <label>End s</label>
              <input id="tlEdEnd" type="number" step="0.001" min="0" />
            </div>
          </div>
          <div class="btnbar">
            <button id="tlEdApplyBtn" class="primary" type="button">Apply</button>
            <button id="tlEdResetStartBtn" type="button">Reset start</button>
          </div>
        </div>
        <div class="legend" id="chartLegend"></div>
      </div>
      </div><!-- /panelHdrBody timeline -->
    </div>

    <div id="panelCyclesBlock" class="panelBlock">
      <button class="panelHdr" data-panel-hdr="cycles">
        <span class="panelHdrTitle">Cycles</span>
        <span class="panelHdrChevron">›</span>
      </button>
      <div class="panelHdrBody">
      
      <div class="card" style="padding:12px; border-radius:14px;">
        <div class="small muted">Checkbox selects line (Selected mode). Tag editable per cycle.</div>

        <div class="scrollBox noScroll" style="margin-top:10px;">
          <table>
            <thead>
              <tr>
                  <th style="width:44px;" title="Check to include cycle in timeline graph (Selected mode)">
                    <div style="display:flex;flex-direction:column;gap:4px;align-items:center;">
                      <div class="small" style="font-size:10px;">Graph</div>
                      <button id="invertSelectionBtn" class="miniBtn" type="button" title="Invert current selection" style="font-size:10px;padding:2px 5px;border-radius:6px;">Inv</button>
                    </div>
                  </th>
                  <th style="width:64px;">#</th>
                  <th>Captured</th>
                  <th style="width:160px;">Tag</th>
                  <th class="right" style="width:150px;">Total</th>
                  <th class="right" style="width:120px;">Detail</th>
                </tr>
            </thead>
            <tbody id="cyclesBody"></tbody>
          </table>
        </div>
      
      </div><!-- /panelHdrBody cycles -->
    </div>
    </div>
  </section>
</main>

<!-- RIGHT DRAWER: job config / elements / backup -->
<div id="drawerRoot">
  <div class="drawerOverlay" id="drawerOverlay"></div>
  <aside class="drawer" id="drawer">
    <div class="drawerHeader">
      <div>
        <div class="drawerTitle">Config</div>
        <div class="small muted">Job setup - Elements - Backup</div>
      </div>
      <button id="closeDrawerBtn" style="font-size:16px; line-height:1; padding:8px 12px;">×</button>
    </div>
    <div class="drawerBody" id="drawerBody">
      <section class="drawerSection" data-drawer-sec="job">
        <button class="drawerSecBtn" type="button" data-drawer-sec-btn="job">
          <span class="drawerBurgerIcon">☰</span>
          <span class="title" id="drawerSecTitleJob">Job</span>
          <span class="drawerSecChevron">▾</span>
        </button>
        <div class="drawerSecBody">
          <div class="row">
            <!-- Job quick-switch -->
            <div>
              <label id="lblActiveJob">Active job</label>
              <select id="jobSwitchSel" title="Switch to a different job instantly"></select>
            </div>

            <div class="row2">
              <div>
                <label>Station</label>
                <select id="jobStationSelect"></select>
              </div>
              <div>
                <label>Job name</label>
                <input id="jobName" placeholder="e.g., Final tighten & inspect" />
              </div>
            </div>

            <div class="row3">
              <div>
                <label>Allowance %</label>
                <input id="allowancePct" type="number" step="0.1" min="0" value="12" />
              </div>
              <div>
                <label>Rating %</label>
                <input id="ratingPct" type="number" step="1" min="50" max="150" value="100" />
              </div>
              <div>
                <label>Station code</label>
                <input id="stationCodeView" disabled />
              </div>
            </div>

            <div class="btnbar">
              <button class="primary" id="newJobBtn">+ New Job</button>
              <button id="dupJobBtn">Duplicate</button>
              <button class="danger" id="delJobBtn">Delete</button>
            </div>
          </div>
        </div>
      </section>

      <section class="drawerSection" data-drawer-sec="elements">
        <button class="drawerSecBtn" type="button" data-drawer-sec-btn="elements">
          <span class="drawerBurgerIcon">☰</span>
          <span class="title" id="drawerSecTitleElements">Elements</span>
          <span class="drawerSecChevron">▾</span>
        </button>
        <div class="drawerSecBody">
          <div class="row">
            <div class="row2">
              <div>
                <label>Element name</label>
                <input id="elName" placeholder="e.g., Pick part" />
              </div>
              <div>
                <label>Type</label>
                <select id="elType">
                  <option value="HUMAN">HUMAN</option>
                  <option value="MACHINE">MACHINE</option>
                  <option value="HUMAN+MACHINE">HUMAN+MACHINE</option>
                  <option value="IDLE">IDLE</option>
                </select>
              </div>
            </div>

            <div class="btnbar">
              <button class="primary" id="addElBtn">Add</button>
              <button id="moveUpBtn">Up</button>
              <button id="moveDownBtn">Down</button>
              <button class="danger" id="deleteElBtn">Delete</button>
            </div>
            <div class="small muted">Click an element row to select it.</div>

            <div class="scrollBox" style="max-height:220px;">
              <table>
                <thead>
                  <tr>
                    <th style="width:38px;">#</th>
                    <th>Element</th>
                    <th style="width:140px;">Type</th>
                  </tr>
                </thead>
                <tbody id="elementsBody"></tbody>
              </table>
            </div>
          </div>
        </div>
      </section>

      <section class="drawerSection" data-drawer-sec="actionTypes">
        <button class="drawerSecBtn" type="button" data-drawer-sec-btn="actionTypes">
          <span class="drawerBurgerIcon">☰</span>
          <span class="title" id="drawerSecTitleActionTypes">Action Types</span>
          <span class="drawerSecChevron">▾</span>
        </button>
        <div class="drawerSecBody">
          <div class="row">
            <div class="row3">
              <div>
                <label>Type ID</label>
                <input id="atId" placeholder="HUMAN" style="text-transform:uppercase;" oninput="this.value=this.value.toUpperCase()" />
              </div>
              <div>
                <label>Name</label>
                <input id="atName" placeholder="Human" />
              </div>
              <div>
                <label>Lane</label>
                <input id="atLane" placeholder="human" />
              </div>
            </div>
            <div class="row3">
              <div>
                <label>Color</label>
                <input id="atColor" type="color" value="#ffd24a" />
              </div>
              <div>
                <label>Height (px)</label>
                <input id="atHeight" type="number" min="1" max="40" value="6" />
              </div>
              <div>
                <label>Lane order</label>
                <input id="atLaneOrder" type="number" step="1" value="0" />
              </div>
            </div>
            <div class="row3">
              <div>
                <label>Z order</label>
                <input id="atZ" type="number" step="1" value="10" />
              </div>
              <div>
                <label>Opacity %</label>
                <input id="atOpacity" type="number" min="1" max="100" value="100" />
              </div>
              <div>
                <label>Underlay type</label>
                <select id="atUnderlay">
                  <option value="">(none)</option>
                </select>
              </div>
            </div>
            <div class="btnbar" style="margin-top:-2px;">
              <label class="chip" title="When enabled, this action type pushes next actions on the same resource/lane when duration grows.">
                <input class="checkbox" id="atStackFlow" type="checkbox" checked /> Push next actions (stack)
              </label>
            </div>
            <div class="row2">
              <div>
                <label>Resource behavior</label>
                <select id="atResourceMode">
                  <option value="AUTO">Auto (from ID/name)</option>
                  <option value="HUMAN">Human only</option>
                  <option value="MACHINE">Machine only</option>
                  <option value="BOTH">Human + Machine</option>
                  <option value="LANE">Lane only</option>
                  <option value="FREE">Free overlap</option>
                </select>
              </div>
              <div></div>
            </div>
            <div class="btnbar">
              <button class="primary" id="addActionTypeBtn">+ Type</button>
              <button id="clearTypeFormBtn" type="button" title="Clear form / create new type">✕ Clear</button>
            </div>
            <div class="small muted">Z order controls draw priority: higher Z draws on top (e.g. HUMAN Z=20 over MACHINE Z=5). Lane separates rows vertically. Height sets bar thickness. Stack controls whether this type pushes following actions. Resource behavior controls which lanes/resources are blocked.</div>
            <div class="scrollBox noScroll" style="margin-top:8px;">
              <table>
                <thead>
                  <tr>
                    <th style="width:100px;">ID</th>
                    <th>Name</th>
                    <th style="width:80px;">Lane</th>
                    <th style="width:60px;">H</th>
                    <th style="width:60px;">Z</th>
                    <th style="width:70px;">Stack</th>
                    <th style="width:90px;">Behavior</th>
                    <th style="width:70px;">Color</th>
                    <th style="width:80px;">Action</th>
                  </tr>
                </thead>
                <tbody id="actionTypesBody"></tbody>
              </table>
            </div>
          </div>
        </div>
      </section>

      <section class="drawerSection" data-drawer-sec="view">
        <button class="drawerSecBtn" type="button" data-drawer-sec-btn="view">
          <span class="drawerBurgerIcon">☰</span>
          <span class="title" id="drawerSecTitleView">View & Layout</span>
          <span class="drawerSecChevron">▾</span>
        </button>
        <div class="drawerSecBody">
          <div class="row">
            <!-- Theme presets -->
            <div>
              <label id="lblThemePresets">Theme presets</label>
              <div class="themePresetRow" id="themePresetRow">
                <button class="tpBtn" type="button" data-tp="dark"
                  style="--c-bg:#0b0c10;--c-acc:#4c73ff;">
                  <span class="tpSwatch"></span>Dark
                </button>
                <button class="tpBtn" type="button" data-tp="midnight"
                  style="--c-bg:#060a1a;--c-acc:#33cfff;">
                  <span class="tpSwatch"></span>Midnight
                </button>
                <button class="tpBtn" type="button" data-tp="forest"
                  style="--c-bg:#0a120a;--c-acc:#42d18b;">
                  <span class="tpSwatch"></span>Forest
                </button>
                <button class="tpBtn" type="button" data-tp="ember"
                  style="--c-bg:#120a0a;--c-acc:#ff6b35;">
                  <span class="tpSwatch"></span>Ember
                </button>
                <button class="tpBtn" type="button" data-tp="light"
                  style="--c-bg:#f0f2f5;--c-acc:#4c73ff;">
                  <span class="tpSwatch" style="border-color:rgba(0,0,0,.15);"></span>Light
                </button>
              </div>
            </div>
            <!-- Custom colors -->
            <div class="row3">
              <div>
                <label id="uiBgColorLabel">Background</label>
                <input id="uiBgColor" type="color" value="#0b0c10" />
              </div>
              <div>
                <label id="uiTextColorLabel">Text</label>
                <input id="uiTextColor" type="color" value="#e8e8e8" />
              </div>
              <div>
                <label id="uiAccentColorLabel">Accent</label>
                <input id="uiAccentColor" type="color" value="#4c73ff" />
              </div>
            </div>
            <div class="hr" style="margin:8px 0;"></div>
            <div class="row2">
              <div>
                <label id="uiScaleLabel">UI Scale</label>
                <input id="uiScaleRange" type="range" min="20" max="200" step="1" value="100" />
              </div>
              <div>
                <label id="uiScaleValueLabel">Scale value</label>
                <input id="uiScaleInput" type="number" min="0.2" max="2" step="0.05" value="1" />
              </div>
            </div>
            <div class="row2">
              <div>
                <label id="uiLayoutModeLabel">Layout mode</label>
                <select id="uiLayoutModeSel">
                  <option value="horizontal">Horizontal (side by side)</option>
                  <option value="vertical">Vertical (stacked)</option>
                </select>
              </div>
              <div>
                <label id="uiPanelLayoutLabel">Panel layout</label>
                <select id="uiPanelLayoutSel">
                  <option value="stack">Stacked cards</option>
                  <option value="grid">Adaptive grid</option>
                </select>
              </div>
            </div>
            <div class="row2" id="uiPanelGridColsWrap" style="display:none;">
              <div>
                <label id="uiPanelGridColsLabel">Grid columns</label>
                <input id="uiPanelGridColsRange" type="range" min="1" max="4" step="1" value="2" />
                <div class="small muted mono" id="uiPanelGridColsValue">2 cols</div>
              </div>
            </div>
            <div class="row2">
              <div>
                <label id="uiJobsWidthLabelTitle">Jobs panel width</label>
                <input id="uiJobsWidthRange" type="range" min="240" max="640" step="10" value="360" />
                <div class="small muted mono" id="uiJobsWidthLabel">360 px</div>
              </div>
            </div>
            <div class="row2">
              <div>
                <label id="uiTimeUnitLabel">Time unit</label>
                <select id="uiTimeUnitSel">
                  <option value="s">Seconds</option>
                  <option value="min">Minutes</option>
                </select>
              </div>
              <div>
                <label id="uiTimeResolutionLabel">Resolution (s)</label>
                <select id="uiTimeResolutionSel">
                  <option value="1">1</option>
                  <option value="0.1">0.1</option>
                  <option value="0.01">0.01</option>
                  <option value="0.001">0.001</option>
                </select>
              </div>
            </div>
            <div class="btnbar" style="margin-top:4px;">
              <label class="chip"><input class="checkbox" id="uiTimelineSameBaseChk" type="checkbox" checked /> Timeline same base</label>
              <button id="uiResetBtn" type="button">↺ Reset defaults</button>
            </div>
            <div class="small muted" id="uiLayoutHint">Layout settings are saved locally and exported in JSON.</div>
          </div>
        </div>
      </section>

      <section class="drawerSection" data-drawer-sec="backup">
        <button class="drawerSecBtn" type="button" data-drawer-sec-btn="backup">
          <span class="drawerBurgerIcon">☰</span>
          <span class="title" id="drawerSecTitleBackup">Backup</span>
          <span class="drawerSecChevron">▾</span>
        </button>
        <div class="drawerSecBody">
          <div class="row">
            <div class="btnbar">
              <button id="exportJsonBtn">Export JSON</button>
              <button id="importJsonBtn">Import JSON</button>
              <input id="importFile" type="file" accept=".json" style="display:none" />
              <button id="exportCsvBtn">Export CSV</button>
            </div>
            <div class="btnbar" style="margin-top:8px;">
              <button id="demoSmallBtn">Demo Small</button>
              <button id="demoMediumBtn">Demo Medium</button>
              <button id="demoLargeBtn">Demo Large</button>
              <button id="clearLocalBtn" class="danger">Clear Local</button>
            </div>
            <div class="small muted">CSV includes tags. Notes are JSON-only.</div>
          </div>
        </div>
      </section>
    </div>
  </aside>
</div>

<script>
(() => {
  const STORAGE_KEY = "chrono_drawer_timeline_v5";
  const VIDEO_BOOKMARKS_KEY = "chrono_video_bookmarks_v1";
  const LANG_STORAGE_KEY = "chrono_ui_lang_v1";
  const I18N_INDEX_URL = "./i18n/index.json";
  const $ = (id) => document.getElementById(id);
  const wallIso = () => new Date().toISOString();
  const perfNow = () => performance.now();
  const TAGS = ["Normal","Rework","Training","Disturbance"];

  const EN_STRINGS = {
    "title": "Chrono Study",
    "saved": "Saved locally",
    "config": "Config",
    "menuConfig": "Menu Config",
    "hideJobs": "Hide Jobs",
    "showJobs": "Show Jobs",
    "jobs": "Jobs",
    "collapseAll": "Collapse all",
    "expandAll": "Expand all",
    "stationJob": "Stations & Jobs",
    "pickJobHint": "Pick a job, then time cycles. Config is in the right drawer.",
    "searchPh": "Search station/job...",
    "clear": "Clear",
    "addStation": "+ Station",
    "timer": "Timer",
    "currentElapsed": "Current elapsed",
    "currentElement": "Current element",
    "index": "Index",
    "captureMode": "Capture mode",
    "continuousMode": "Continuous sequence",
    "singleMode": "Single action repeat",
    "videoMode": "Video capture",
    "singleAction": "Single action",
    "videoFile": "Video file",
    "videoAction": "Video action",
    "selectedAction": "Selected action",
    "videoTimeline": "Video timeline",
    "scalePct": "Cycle scale %",
    "scaleHelp": "Applies when creating cycle from markers.",
    "autoStackRules": "Auto stack by rules",
    "applyStack": "Apply stack",
    "wait": "Wait",
    "mark": "Mark",
    "cycle": "Cycle",
    "markStartEnd": "Mark start/end",
    "markStart": "Mark start",
    "markEnd": "Mark end",
    "playStart": "Play + start",
    "playNext": "Play + next",
    "markNext": "Mark next",
    "createCycleFromMarkers": "Create cycle from markers",
    "clearMarkers": "Clear markers",
    "noMarkers": "No markers",
    "start": "Start",
    "next": "Next",
    "finishCycle": "Finish cycle",
    "undo": "Undo",
    "clearCycles": "Clear cycles",
    "spaceHint": "Space = Start/Next/Finish - Backspace = Undo",
    "selectJob": "Select a job",
    "recordCycles": "Record cycles to compute.",
    "noData": "No data",
    "addElementsInConfig": "Add elements in Config",
    "markers": "Markers",
    "videoHint": "Mark start/end, then create cycle from markers",
    "singleHint": "Start, capture repeats, then Finish cycle",
    "pressStart": "Press Start",
    "captures": "Captures",
    "captureLap": "Capture lap",
    "captureEachHint": "Capture each repeat, then Finish cycle",
    "finishToSave": "Finish to save cycle",
    "tapNext": "Tap Next",
    "kpi": "KPI",
    "timeline": "Timeline graph (stacked bars)",
    "timelineEditHint": "Graph edit: drag a segment to move, drag right edge to resize. Same lane = same base level.",
    "timelineSameBase": "Timeline same base",
    "cycles": "Cycles",
    "selected": "Selected",
    "all": "All",
    "outliers": "Outliers",
    "avgMarkers": "Avg markers",
    "tags": "Tags",
    "selectLast3": "Select last 3",
    "clearSelection": "Clear selection",
    "notesOptional": "Notes (optional)",
    "notesPh": "e.g., paused, missing part, machine jam...",
    "notesHint": "Notes stored locally + JSON.",
    "configTitle": "Config",
    "jobSetupSub": "Job setup - Elements - Backup",
    "job": "Job",
    "station": "Station",
    "jobName": "Job name",
    "allowancePct": "Allowance %",
    "ratingPct": "Rating %",
    "stationCode": "Station code",
    "newJob": "+ New Job",
    "duplicate": "Duplicate",
    "delete": "Delete",
    "elements": "Elements",
    "elementName": "Element name",
    "type": "Type",
    "add": "Add",
    "up": "Up",
    "down": "Down",
    "clickElementHint": "Click an element row to select it.",
    "actionTypes": "Action Types",
    "viewLayout": "View & Layout",
    "uiScale": "UI Scale",
    "uiScaleValue": "UI Scale x",
    "uiLayoutMode": "Layout mode",
    "uiLayoutHorizontal": "Horizontal (side by side)",
    "uiLayoutVertical": "Vertical (stacked)",
    "uiPanelLayout": "Panel layout",
    "uiPanelLayoutStack": "Stacked cards",
    "uiPanelLayoutGrid": "Adaptive grid",
    "uiPanelGridCols": "Grid columns",
    "uiPanelGridColsValue": "cols",
    "uiJobsWidth": "Jobs panel width (px)",
    "uiBgColor": "Background",
    "uiTextColor": "Text",
    "uiAccentColor": "Accent",
    "uiTimeUnit": "Time unit",
    "uiTimeUnitSec": "Seconds",
    "uiTimeUnitMin": "Minutes",
    "uiTimeResolution": "Time resolution (s)",
    "uiResetDefaults": "Reset UI defaults",
    "uiLayoutHint": "These layout settings are saved in local state and exported in JSON.",
    "exportActionsCsv": "Export CSV",
    "printReport": "🖨 Print / PDF",
    "activeJob": "Active job",
    "themePresets": "Theme presets",
    "scaleValue": "Scale value",
    "jobsPanelWidth": "Jobs panel width",
    "resolutionS": "Resolution (s)",
    "resetDefaults": "↺ Reset defaults",
    "layoutHint": "Layout settings are saved locally and exported in JSON.",
    "backup": "Backup",
    "exportJson": "Export JSON",
    "importJson": "Import JSON",
    "exportCsv": "Export CSV",
    "demoSmall": "Demo Small",
    "demoMedium": "Demo Medium",
    "demoLarge": "Demo Large",
    "clearLocal": "Clear Local",
    "jobsCount": "job(s)",
    "edit": "Edit",
    "cfg": "Cfg",
    "progress": "Progress",
    "els": "els",
    "cyclesLabel": "cycles",
    "noElements": "No elements.",
    "noCyclesRecorded": "No cycles recorded.",
    "allCyclesFiltered": "All cycles",
    "filtered": "filtered",
  };
  const FR_INLINE_STRINGS = {
    "title": "Etude Chrono",
    "saved": "Sauvegarde locale",
    "config": "Config",
    "menuConfig": "Menu Config",
    "hideJobs": "Masquer Jobs",
    "showJobs": "Afficher Jobs",
    "jobs": "Jobs",
    "collapseAll": "Tout replier",
    "expandAll": "Tout deplier",
    "stationJob": "Postes & Jobs",
    "pickJobHint": "Choisissez un job, puis capturez les cycles. Config dans le tiroir a droite.",
    "searchPh": "Rechercher poste/job...",
    "clear": "Effacer",
    "addStation": "+ Poste",
    "timer": "Chrono",
    "currentElapsed": "Temps courant",
    "currentElement": "Element courant",
    "index": "Index",
    "captureMode": "Mode capture",
    "continuousMode": "Sequence continue",
    "singleMode": "Action unique repetee",
    "videoMode": "Capture video",
    "singleAction": "Action unique",
    "videoFile": "Fichier video",
    "videoAction": "Action video",
    "selectedAction": "Action selectionnee",
    "videoTimeline": "Timeline video",
    "scalePct": "Echelle cycle %",
    "scaleHelp": "Applique lors de la creation du cycle depuis les marqueurs.",
    "autoStackRules": "Empilement auto par regles",
    "applyStack": "Appliquer empilement",
    "wait": "Attente",
    "mark": "Marque",
    "cycle": "Cycle",
    "markStartEnd": "Marquer debut/fin",
    "markStart": "Marquer debut",
    "markEnd": "Marquer fin",
    "playStart": "Lire + debut",
    "playNext": "Lire + suivant",
    "markNext": "Marquer suivant",
    "createCycleFromMarkers": "Creer cycle depuis marqueurs",
    "clearMarkers": "Effacer marqueurs",
    "noMarkers": "Aucun marqueur",
    "start": "Demarrer",
    "next": "Suivant",
    "finishCycle": "Finir cycle",
    "undo": "Annuler",
    "clearCycles": "Effacer cycles",
    "spaceHint": "Espace = Demarrer/Suivant/Fin - Retour arriere = Annuler",
    "selectJob": "Selectionnez un job",
    "recordCycles": "Enregistrez des cycles pour calculer.",
    "noData": "Pas de donnees",
    "addElementsInConfig": "Ajoutez des elements dans Config",
    "markers": "Marqueurs",
    "videoHint": "Marquez debut/fin puis creez un cycle depuis marqueurs",
    "singleHint": "Demarrez, capturez les repetitions, puis Finir cycle",
    "pressStart": "Appuyez sur Demarrer",
    "captures": "Captures",
    "captureLap": "Capture tour",
    "captureEachHint": "Capturez chaque repetition puis Finir cycle",
    "finishToSave": "Finir pour sauver le cycle",
    "tapNext": "Appuyez Suivant",
    "kpi": "KPI",
    "timeline": "Timeline (barres empilees)",
    "timelineEditHint": "Edition graphe: glisser pour deplacer, bord droit pour redimensionner. Meme lane = meme niveau de base.",
    "timelineSameBase": "Timeline meme base",
    "cycles": "Cycles",
    "selected": "Selection",
    "all": "Tout",
    "outliers": "Valeurs anormales",
    "avgMarkers": "Reperes moy.",
    "tags": "Tags",
    "selectLast3": "3 derniers",
    "clearSelection": "Effacer selection",
    "notesOptional": "Notes (optionnel)",
    "notesPh": "ex: pause, piece manquante, blocage machine...",
    "notesHint": "Notes stockees en local + JSON.",
    "configTitle": "Config",
    "jobSetupSub": "Setup job - Elements - Sauvegarde",
    "job": "Job",
    "station": "Poste",
    "jobName": "Nom du job",
    "allowancePct": "Allowance %",
    "ratingPct": "Rating %",
    "stationCode": "Code poste",
    "newJob": "+ Nouveau Job",
    "duplicate": "Dupliquer",
    "delete": "Supprimer",
    "elements": "Elements",
    "elementName": "Nom element",
    "type": "Type",
    "add": "Ajouter",
    "up": "Monter",
    "down": "Descendre",
    "clickElementHint": "Cliquez une ligne element pour selectionner.",
    "actionTypes": "Types action",
    "viewLayout": "Vue & Layout",
    "uiScale": "Echelle UI",
    "uiScaleValue": "Echelle UI x",
    "uiLayoutMode": "Mode layout",
    "uiLayoutHorizontal": "Horizontal (cote a cote)",
    "uiLayoutVertical": "Vertical (empile)",
    "uiPanelLayout": "Disposition panneaux",
    "uiPanelLayoutStack": "Cartes empilees",
    "uiPanelLayoutGrid": "Grille adaptative",
    "uiPanelGridCols": "Colonnes grille",
    "uiPanelGridColsValue": "colonnes",
    "uiJobsWidth": "Largeur panneau jobs (px)",
    "uiBgColor": "Fond",
    "uiTextColor": "Texte",
    "uiAccentColor": "Accent",
    "uiTimeUnit": "Unite de temps",
    "uiTimeUnitSec": "Secondes",
    "uiTimeUnitMin": "Minutes",
    "uiTimeResolution": "Resolution temps (s)",
    "uiResetDefaults": "Reset UI par defaut",
    "uiLayoutHint": "Ces reglages layout sont sauvegardes en local et exportes en JSON.",
    "exportActionsCsv": "Exporter actions CSV",
    "printReport": "🖨 Imprimer / PDF",
    "activeJob": "Job actif",
    "themePresets": "Thèmes prédéfinis",
    "scaleValue": "Valeur échelle",
    "jobsPanelWidth": "Largeur panneau jobs",
    "resolutionS": "Résolution (s)",
    "resetDefaults": "↺ Réinitialiser",
    "layoutHint": "Les réglages layout sont sauvegardés localement et exportés en JSON.",
    "backup": "Sauvegarde",
    "exportJson": "Exporter JSON",
    "importJson": "Importer JSON",
    "exportCsv": "Exporter CSV",
    "demoSmall": "Demo Petite",
    "demoMedium": "Demo Moyenne",
    "demoLarge": "Demo Grande",
    "clearLocal": "Effacer Local",
    "jobsCount": "job(s)",
    "edit": "Editer",
    "cfg": "Cfg",
    "progress": "Progression",
    "els": "elts",
    "cyclesLabel": "cycles",
    "noElements": "Aucun element.",
    "noCyclesRecorded": "Aucun cycle enregistre.",
    "allCyclesFiltered": "Tous cycles",
    "filtered": "filtres",
  };
  let i18nCatalogs = {
    en: { code: "en", name: "English", translations: EN_STRINGS },
    fr: { code: "fr", name: "Francais", translations: FR_INLINE_STRINGS },
  };
  let activeLanguage = "en";

  function t(k, fallback = "") {
    return i18nCatalogs[activeLanguage]?.translations?.[k] ?? EN_STRINGS[k] ?? fallback ?? k;
  }
  async function loadLanguageCatalogs() {
    try {
      const idxRes = await fetch(I18N_INDEX_URL, { cache: "no-store" });
      if (!idxRes.ok) return;
      const idx = await idxRes.json();
      const files = Array.isArray(idx?.files) ? idx.files : [];
      for (const file of files) {
        try {
          const r = await fetch(`./i18n/${file}`, { cache: "no-store" });
          if (!r.ok) continue;
          const payload = await r.json();
          if (!payload?.code || !payload?.translations) continue;
          i18nCatalogs[payload.code] = {
            code: String(payload.code),
            name: String(payload.name || payload.code),
            translations: { ...i18nCatalogs[payload.code]?.translations, ...payload.translations },
          };
        } catch {}
      }
    } catch {}
  }
  function applyI18nStatic() {
    const setText = (selector, key, fallback) => {
      const el = document.querySelector(selector);
      if (el) el.textContent = t(key, fallback);
    };
    const setPlaceholder = (selector, key, fallback) => {
      const el = document.querySelector(selector);
      if (el) el.placeholder = t(key, fallback);
    };
    const h1 = document.querySelector("header h1");
    if (h1) h1.textContent = t("title", "Chrono Study");
    const hdrSub = document.querySelector("header .sub");
    if (hdrSub) hdrSub.textContent = "";
    const savePill = $("savePill");
    if (savePill) { /* flash-based, no static text */ }
    const cfgBtn = $("openDrawerBtn");
    if (cfgBtn) { const lbl = $("hConfigLabel"); if (lbl) lbl.textContent = t("config", "Config"); }
    const leftBtn = $("toggleLeftPanelBtn");
    if (leftBtn) leftBtn.textContent = state?.ui?.leftPanelVisible ? t("hideJobs", "Hide Jobs") : t("showJobs", "Show Jobs");
    const stTitle = document.querySelector("#leftPanelSection [data-panel-hdr='jobsSidebar'] .panelHdrTitle");
    if (stTitle) stTitle.textContent = t("stationJob", "Stations & Jobs");
    const stHint = document.querySelector(".sidebarTop .small");
    if (stHint) stHint.textContent = t("pickJobHint", "Pick a job, then time cycles. Config is in the right drawer.");
    setText("#newStationBtn", "addStation", "+ Station");
    const collapseBtn = $("collapseStationsBtn");
    if (collapseBtn) { collapseBtn.textContent = "-"; collapseBtn.title = t("collapseAll", "Collapse all"); }
    const expandBtn = $("expandStationsBtn");
    if (expandBtn) { expandBtn.textContent = "+"; expandBtn.title = t("expandAll", "Expand all"); }
    setText("#clearSearchBtn", "clear", "Clear");
    setPlaceholder("#searchBox", "searchPh", "Search station/job...");
    const tTitle = document.querySelector("#jobHeader")?.parentElement?.querySelector(".title");
    if (tTitle) tTitle.textContent = t("timer", "Timer");
    setText("#panelTimerCard .small.muted", "currentElapsed", "Current elapsed");
    const elCard = document.querySelector("#panelTimerCard > div:nth-child(3) > div:nth-child(1) > div.small.muted");
    if (elCard) elCard.textContent = t("currentElement", "Current element");
    const idxCard = document.querySelector("#panelTimerCard > div:nth-child(3) > div:nth-child(2) > div.small.muted");
    if (idxCard) idxCard.textContent = t("index", "Index");
    const capModeLbl = $("captureModeSel")?.closest("div")?.querySelector("label");
    if (capModeLbl) capModeLbl.textContent = t("captureMode", "Capture mode");
    const capOpts = $("captureModeSel")?.options;
    if (capOpts && capOpts.length >= 3) {
      capOpts[0].textContent = t("continuousMode", "Continuous sequence");
      capOpts[1].textContent = t("singleMode", "Single action repeat");
      capOpts[2].textContent = t("videoMode", "Video capture");
    }
    const singleLbl = $("singleActionSel")?.closest("div")?.querySelector("label");
    if (singleLbl) singleLbl.textContent = t("singleAction", "Single action");
    const videoFileLbl = $("videoFile")?.closest("div")?.querySelector("label");
    if (videoFileLbl) videoFileLbl.textContent = t("videoFile", "Video file");
    const videoTimelineLbl = $("videoTimeline")?.parentElement?.querySelector("label");
    if (videoTimelineLbl) videoTimelineLbl.textContent = t("videoTimeline", "Video timeline");
    const actionText = $("videoActionText");
    if (actionText && (!actionText.textContent || actionText.textContent === "-")) actionText.textContent = t("selectedAction", "Selected action");
    setText("#videoSeqBtn", "playNext", "Play + next");
    setText("#videoManualStartBtn", "markStart", "Mark start");
    setText("#videoManualEndBtn", "markEnd", "Mark end");
    setText("#videoApplyBtn", "createCycleFromMarkers", "Create cycle from markers");
    setText("#videoClearBtn", "clearMarkers", "Clear markers");
    setText("#videoAutoStackBtn", "applyStack", "Apply stack");
    const stackLbl = $("videoStackRulesChk")?.parentElement;
    if (stackLbl) {
      const txtNode = stackLbl.childNodes[stackLbl.childNodes.length - 1];
      if (txtNode && txtNode.nodeType === Node.TEXT_NODE) txtNode.textContent = ` ${t("autoStackRules", "Auto stack by rules")}`;
    }
    const waitInfo = $("videoWaitInfo");
    if (waitInfo) {
      const cur = waitInfo.textContent || "";
      const sep = cur.includes(":") ? cur.slice(cur.indexOf(":")) : `: ${fmtQtySec(0)}`;
      waitInfo.textContent = `${t("wait", "Wait")}${sep}`;
    }
    if (!$("videoMarkersList")?.innerHTML || $("videoMarkersList")?.textContent === "No markers") {
      setText("#videoMarkersList", "noMarkers", "No markers");
    }
    setText("#mainBtn", "start", "Start");
    setText("#finishCycleBtn", "finishCycle", "Finish cycle");
    setText("#undoBtn", "undo", "Undo");
    setText("#clearJobCyclesBtn", "clearCycles", "Clear cycles");
    const sh = $("timerKeyboardHint");
    if (sh) sh.textContent = t("spaceHint", "Space = Start/Next/Finish - Backspace = Undo");
    setText("#panelKpiCard .title", "kpi", "KPI");
    const tlTitle = document.querySelector("main .title[style*='margin-bottom:8px']");
    if (tlTitle) tlTitle.textContent = t("timeline", "Timeline graph (stacked bars)");
    setText("#timelineEditHint", "timelineEditHint", "Graph edit: drag a segment to move, drag right edge to resize. Same lane = same base level.");
    const cyTitle = document.querySelectorAll("main .title");
    if (cyTitle?.length > 0) {
      const lastTitle = cyTitle[cyTitle.length - 1];
      if (lastTitle && lastTitle.textContent?.trim() === "Cycles") lastTitle.textContent = t("cycles", "Cycles");
    }
    const modeSelected = $("modeSelectedBtn"); if (modeSelected) modeSelected.textContent = t("selected", "Selected");
    const modeAll = $("modeAllBtn"); if (modeAll) modeAll.textContent = t("all", "All");
    const showOutInput = $("showOutliersChk");
    if (showOutInput?.parentElement) showOutInput.parentElement.lastChild.textContent = ` ${t("outliers", "Outliers")}`;
    const showAvgInput = $("showAvgLineChk");
    if (showAvgInput?.parentElement) showAvgInput.parentElement.lastChild.textContent = ` ${t("avgMarkers", "Avg markers")}`;
    const tagsPill = document.querySelector(".toolbar .pill");
    if (tagsPill) tagsPill.textContent = t("tags", "Tags");
    const bSelLast = $("selectLast3Btn"); if (bSelLast) bSelLast.textContent = t("selectLast3", "Select last 3");
    const bClrSel = $("clearSelectionBtn"); if (bClrSel) bClrSel.textContent = t("clearSelection", "Clear selection");
    const bTlCfg = $("timelineConfigBtn"); if (bTlCfg) bTlCfg.textContent = t("config", "Config");
    setText("#kpiExportCsvBtn", "exportActionsCsv", "Export CSV");
    setText("#kpiPrintBtn", "printReport", "🖨 Print / PDF");
    const sameBaseLbl = $("uiTimelineSameBaseChk")?.parentElement;
    if (sameBaseLbl) {
      const txtNode = sameBaseLbl.childNodes[sameBaseLbl.childNodes.length - 1];
      if (txtNode && txtNode.nodeType === Node.TEXT_NODE) txtNode.textContent = ` ${t("timelineSameBase", "Timeline same base")}`;
    }
    setText("#uiScaleLabel", "uiScale", "UI Scale");
    setText("#uiScaleValueLabel", "scaleValue", "Scale value");
    setText("#uiLayoutModeLabel", "uiLayoutMode", "Layout mode");
    setText("#uiPanelLayoutLabel", "uiPanelLayout", "Panel layout");
    setText("#uiPanelGridColsLabel", "uiPanelGridCols", "Grid columns");
    setText("#uiJobsWidthLabelTitle", "jobsPanelWidth", "Jobs panel width");
    setText("#uiBgColorLabel", "uiBgColor", "Background");
    setText("#uiTextColorLabel", "uiTextColor", "Text");
    setText("#uiAccentColorLabel", "uiAccentColor", "Accent");
    setText("#uiTimeUnitLabel", "uiTimeUnit", "Time unit");
    setText("#uiTimeResolutionLabel", "resolutionS", "Resolution (s)");
    setText("#uiResetBtn", "resetDefaults", "↺ Reset defaults");
    setText("#uiLayoutHint", "layoutHint", "Layout settings are saved locally and exported in JSON.");
    const lblActiveJob = $("lblActiveJob"); if (lblActiveJob) lblActiveJob.textContent = t("activeJob", "Active job");
    const lblTheme = $("lblThemePresets"); if (lblTheme) lblTheme.textContent = t("themePresets", "Theme presets");
    const modeSel = $("uiLayoutModeSel");
    if (modeSel && modeSel.options.length >= 2) {
      modeSel.options[0].textContent = t("uiLayoutHorizontal", "Horizontal (side by side)");
      modeSel.options[1].textContent = t("uiLayoutVertical", "Vertical (stacked)");
    }
    const panelLayoutSel = $("uiPanelLayoutSel");
    if (panelLayoutSel && panelLayoutSel.options.length >= 2) {
      panelLayoutSel.options[0].textContent = t("uiPanelLayoutStack", "Stacked cards");
      panelLayoutSel.options[1].textContent = t("uiPanelLayoutGrid", "Adaptive grid");
    }
    const quickLayoutSel = $("quickPanelLayoutSel");
    if (quickLayoutSel && quickLayoutSel.options.length >= 2) {
      quickLayoutSel.options[0].textContent = t("uiPanelLayoutStack", "Stacked cards");
      quickLayoutSel.options[1].textContent = t("uiPanelLayoutGrid", "Adaptive grid");
      quickLayoutSel.title = t("uiPanelLayout", "Panel layout");
    }
    const unitSel = $("uiTimeUnitSel");
    if (unitSel && unitSel.options.length >= 2) {
      unitSel.options[0].textContent = t("uiTimeUnitSec", "Seconds");
      unitSel.options[1].textContent = t("uiTimeUnitMin", "Minutes");
    }

    const noteHints = document.querySelectorAll(".small.muted");
    noteHints.forEach((x) => {
      if (x.textContent?.includes("Notes stored locally")) x.textContent = t("notesHint", "Notes stored locally + JSON.");
    });

    setText("#drawer .drawerTitle", "configTitle", "Config");
    setText("#drawer .drawerHeader .small.muted", "jobSetupSub", "Job setup - Elements - Backup");
    setText("#drawerSecTitleJob", "job", "Job");
    setText("#drawerSecTitleElements", "elements", "Elements");
    setText("#drawerSecTitleActionTypes", "actionTypes", "Action Types");
    setText("#drawerSecTitleView", "viewLayout", "View & Layout");
    setText("#drawerSecTitleBackup", "backup", "Backup");
    // Job section labels — use id-based selectors to be robust
    setText("#lblActiveJob", "activeJob", "Active job");
    const jsl = $("jobStationSelect")?.closest("div")?.querySelector("label");
    if (jsl) jsl.textContent = t("station", "Station");
    const jnl = $("jobName")?.closest("div")?.querySelector("label");
    if (jnl) jnl.textContent = t("jobName", "Job name");
    const apl = $("allowancePct")?.closest("div")?.querySelector("label");
    if (apl) apl.textContent = t("allowancePct", "Allowance %");
    const rpl = $("ratingPct")?.closest("div")?.querySelector("label");
    if (rpl) rpl.textContent = t("ratingPct", "Rating %");
    const scl = $("stationCodeView")?.closest("div")?.querySelector("label");
    if (scl) scl.textContent = t("stationCode", "Station code");
    const enl = $("elName")?.closest("div")?.querySelector("label");
    if (enl) enl.textContent = t("elementName", "Element name");
    const etl = $("elType")?.closest("div")?.querySelector("label");
    if (etl) etl.textContent = t("type", "Type");
    setText("#newJobBtn", "newJob", "+ New Job");
    setText("#dupJobBtn", "duplicate", "Duplicate");
    setText("#delJobBtn", "delete", "Delete");
    setText("#addElBtn", "add", "Add");
    setText("#moveUpBtn", "up", "Up");
    setText("#moveDownBtn", "down", "Down");
    const clickHint = document.querySelector("#drawer .drawerBody .small.muted");
    if (clickHint && clickHint.textContent?.includes("Click an element row")) clickHint.textContent = t("clickElementHint", "Click an element row to select it.");
    setText("#exportJsonBtn", "exportJson", "Export JSON");
    setText("#importJsonBtn", "importJson", "Import JSON");
    setText("#exportCsvBtn", "exportCsv", "Export CSV");
    setText("#demoSmallBtn", "demoSmall", "Demo Small");
    setText("#demoMediumBtn", "demoMedium", "Demo Medium");
    setText("#demoLargeBtn", "demoLarge", "Demo Large");
    setText("#clearLocalBtn", "clearLocal", "Clear Local");
  }
  async function initI18n() {
    await loadLanguageCatalogs();
    const sel = $("langSelect");
    if (!sel) return;
    sel.innerHTML = "";
    Object.values(i18nCatalogs).sort((a,b) => a.name.localeCompare(b.name)).forEach((lang) => {
      const opt = document.createElement("option");
      opt.value = lang.code;
      opt.textContent = lang.name;
      sel.appendChild(opt);
    });
    const browserLang = String(navigator.language || "en").slice(0,2).toLowerCase();
    const saved = localStorage.getItem(LANG_STORAGE_KEY) || "";
    activeLanguage = i18nCatalogs[saved] ? saved : (i18nCatalogs[browserLang] ? browserLang : "en");
    sel.value = activeLanguage;
    applyI18nStatic();
    sel.addEventListener("change", () => {
      activeLanguage = i18nCatalogs[sel.value] ? sel.value : "en";
      localStorage.setItem(LANG_STORAGE_KEY, activeLanguage);
      applyI18nStatic();
      renderAll();
    });
  }

  function uuid() {
    return (crypto.randomUUID ? crypto.randomUUID()
      : String(Date.now()) + "_" + Math.random().toString(16).slice(2));
  }
  function esc(s) {
    return String(s).replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }
  function fmtMs(ms) {
    const sign = ms < 0 ? "-" : "";
    ms = Math.abs(ms);
    const m = Math.floor(ms / 60000);
    ms -= m * 60000;
    const s = Math.floor(ms / 1000);
    const mm = Math.floor(ms - s * 1000);
    return `${sign}${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}.${String(mm).padStart(3,"0")}`;
  }
  function timeResolutionSec() {
    const q = Number(state?.ui?.timeResolutionSec ?? 0.001);
    return [1, 0.1, 0.01, 0.001].includes(q) ? q : 0.001;
  }
  function timeUnit() {
    return String(state?.ui?.timeDisplayUnit || "s") === "min" ? "min" : "s";
  }
  function quantizeMs(ms) {
    const stepMs = Math.max(1, Math.round(timeResolutionSec() * 1000));
    const n = Number(ms || 0);
    if (!Number.isFinite(n)) return 0;
    return Math.round(n / stepMs) * stepMs;
  }
  function quantizeSec(sec) {
    return quantizeMs(Number(sec || 0) * 1000) / 1000;
  }
  function timeDecimals(unit = timeUnit()) {
    const q = timeResolutionSec();
    if (unit === "min") {
      if (q >= 1) return 2;
      if (q >= 0.1) return 3;
      if (q >= 0.01) return 4;
      return 5;
    }
    if (q >= 1) return 0;
    if (q >= 0.1) return 1;
    if (q >= 0.01) return 2;
    return 3;
  }
  function fmtQtyMs(ms) {
    const u = timeUnit();
    const qms = quantizeMs(ms);
    const sign = qms < 0 ? "-" : "";
    const absMs = Math.abs(qms);
    if (u === "min") {
      const v = absMs / 60000;
      return `${sign}${v.toFixed(timeDecimals("min"))} min`;
    }
    const v = absMs / 1000;
    return `${sign}${v.toFixed(timeDecimals("s"))} s`;
  }
  function fmtQtySec(sec) {
    return fmtQtyMs(Number(sec || 0) * 1000);
  }
  function fmtAxisValue(sec) {
    const u = timeUnit();
    const qsec = quantizeSec(sec);
    const v = u === "min" ? (qsec / 60) : qsec;
    return v.toFixed(timeDecimals(u));
  }
  function downloadText(filename, text, mime="text/plain") {
    const blob = new Blob([text], {type: mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  function toCsvRow(cells) {
    return cells.map(v => {
      const s = String(v ?? "");
      if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
      return s;
    }).join(",");
  }

  function defaultActionTypes() {
    return [
      { id: "MACHINE", name: "Tech", color: "#7f8790", lane: "1", laneOrder: 1, heightPx: 30, z: 5, opacity: 0.9, underlayTypeId: "", stackFlow: true, resourceMode: "MACHINE" },
      { id: "HUMAN", name: "Human", color: "#ffd24a", lane: "1", laneOrder: 1, heightPx: 15, z: 20, opacity: 1.0, underlayTypeId: "", stackFlow: true, resourceMode: "HUMAN" },
      { id: "HUMAN+MACHINE", name: "Human+Tech", color: "#ffd24a", lane: "1", laneOrder: 1, heightPx: 30, z: 25, opacity: 1.0, underlayTypeId: "MACHINE", stackFlow: true, resourceMode: "BOTH" },
      { id: "IDLE", name: "Idle", color: "#4c73ff", lane: "idle", laneOrder: 2, heightPx: 6, z: 12, opacity: 0.8, underlayTypeId: "", stackFlow: true, resourceMode: "LANE" },
    ];
  }
  function inferDefaultStackFlow(v) {
    const txt = `${String(v?.id || "").toUpperCase()} ${String(v?.name || "").toUpperCase()} ${String(v?.lane || "").toUpperCase()}`;
    const machine = /\b(MACHINE|TECH|TECCH|ROBOT|CNC|AUTO)\b/.test(txt);
    const human = /\b(HUMAN|OPERATOR|MANUAL|PERSON)\b/.test(txt);
    return !(machine && !human);
  }
  function normalizeActionType(v) {
    const resourceModeRaw = String(v?.resourceMode || "AUTO").trim().toUpperCase();
    const resourceMode = ["AUTO", "HUMAN", "MACHINE", "BOTH", "LANE", "FREE"].includes(resourceModeRaw)
      ? resourceModeRaw
      : "AUTO";
    return {
      id: String(v?.id || "IDLE").trim().toUpperCase() || "IDLE",
      name: String(v?.name || v?.id || "IDLE").trim() || "IDLE",
      color: /^#[0-9a-fA-F]{6}$/.test(String(v?.color || "")) ? String(v.color) : "#4c73ff",
      lane: String(v?.lane || "lane").trim() || "lane",
      laneOrder: Number.isFinite(Number(v?.laneOrder)) ? Number(v.laneOrder) : 0,
      heightPx: Math.max(1, Math.min(40, Number(v?.heightPx || 6))),
      z: Number.isFinite(Number(v?.z)) ? Number(v.z) : 10,
      opacity: Math.max(0.05, Math.min(1, Number(v?.opacity ?? 1))),
      underlayTypeId: String(v?.underlayTypeId || "").trim().toUpperCase(),
      stackFlow: (typeof v?.stackFlow === "boolean") ? v.stackFlow : true,
      resourceMode,
    };
  }
  function ensureActionTypes(st) {
    if (!Array.isArray(st.actionTypes) || !st.actionTypes.length) st.actionTypes = defaultActionTypes();
    const seen = new Set();
    const norm = [];
    for (const raw of st.actionTypes) {
      const at = normalizeActionType(raw);
      if (seen.has(at.id)) continue;
      seen.add(at.id);
      norm.push(at);
    }
    if (!norm.length) norm.push(...defaultActionTypes());
    st.actionTypes = norm;
    const valid = new Set(st.actionTypes.map((a) => a.id));
    const fallback = st.actionTypes[0].id;
    for (const job of (st.jobs || [])) {
      for (const el of (job.elements || [])) {
        const t = String(el.type || "").toUpperCase();
        el.type = valid.has(t) ? t : fallback;
      }
    }
  }
  function defaultUiState() {
    return {
      uiScale: 1,
      leftPanelVisible: true,
      jobsPanelCollapsed: false,
      collapsedStations: {},
      timelineSameBase: true,
      layoutMode: "horizontal",
      jobsPanelWidth: 360,
      themeBg: "#0b0c10",
      themeText: "#e8e8e8",
      themeAccent: "#4c73ff",
      timeDisplayUnit: "s",
      timeResolutionSec: 0.001,
      drawerPrefVersion: 2,
      drawerSections: {
        job: false,
        elements: false,
        actionTypes: false,
        view: false,
        backup: false,
      },
      panels: {
        timer: true,
        kpi: true,
        timeline: true,
        cycles: true,
      },
      panelOrder: ["timer", "kpi", "timeline", "cycles"],
    };
  }
  function ensureUiState(st) {
    const d = defaultUiState();
    const clamp = (v, lo, hi, def) => {
      const n = Number(v);
      if (!Number.isFinite(n)) return def;
      return Math.max(lo, Math.min(hi, n));
    };
    const hex = (v, def) => /^#[0-9a-fA-F]{6}$/.test(String(v || "")) ? String(v) : def;
    st.ui = st.ui || {};
    st.ui.uiScale = Math.max(0.2, Math.min(2, Number(st.ui.uiScale ?? d.uiScale) || d.uiScale));
    st.ui.leftPanelVisible = st.ui.leftPanelVisible !== false;
    st.ui.jobsPanelCollapsed = st.ui.jobsPanelCollapsed === true;
    st.ui.collapsedStations = (st.ui.collapsedStations && typeof st.ui.collapsedStations === "object")
      ? st.ui.collapsedStations : {};
    st.ui.timelineSameBase = st.ui.timelineSameBase !== false;
    st.ui.layoutMode = (st.ui.layoutMode === "vertical") ? "vertical" : "horizontal";
    st.ui.jobsPanelWidth = clamp(st.ui.jobsPanelWidth ?? d.jobsPanelWidth, 240, 640, d.jobsPanelWidth);
    st.ui.themeBg = hex(st.ui.themeBg, d.themeBg);
    st.ui.themeText = hex(st.ui.themeText, d.themeText);
    st.ui.themeAccent = hex(st.ui.themeAccent, d.themeAccent);
    st.ui.timeDisplayUnit = (String(st.ui.timeDisplayUnit || d.timeDisplayUnit) === "min") ? "min" : "s";
    const q = Number(st.ui.timeResolutionSec ?? d.timeResolutionSec);
    st.ui.timeResolutionSec = [1, 0.1, 0.01, 0.001].includes(q) ? q : d.timeResolutionSec;
    st.ui.drawerPrefVersion = Number.isFinite(Number(st.ui.drawerPrefVersion))
      ? Number(st.ui.drawerPrefVersion)
      : 0;
    st.ui.drawerSections = (st.ui.drawerSections && typeof st.ui.drawerSections === "object")
      ? st.ui.drawerSections : {};
    for (const k of ["job", "elements", "actionTypes", "view", "backup"]) {
      if (!(k in st.ui.drawerSections)) st.ui.drawerSections[k] = false;
    }
    if (st.ui.drawerPrefVersion < 2) {
      for (const k of ["job", "elements", "actionTypes", "view", "backup"]) {
        st.ui.drawerSections[k] = false;
      }
      st.ui.drawerPrefVersion = 2;
    }
    st.ui.panels = st.ui.panels || {};
    st.ui.panels.timer = st.ui.panels.timer !== false;
    st.ui.panels.kpi = st.ui.panels.kpi !== false;
    st.ui.panels.timeline = st.ui.panels.timeline !== false;
    st.ui.panels.cycles = st.ui.panels.cycles !== false;
    const wanted = d.panelOrder;
    const got = Array.isArray(st.ui.panelOrder) ? st.ui.panelOrder.map((x) => String(x)) : [];
    const filtered = got.filter((x) => wanted.includes(x));
    for (const p of wanted) if (!filtered.includes(p)) filtered.push(p);
    st.ui.panelOrder = filtered;
  }
  let _actionTypeMapCache = null;
  let _actionTypeMapVersion = -1;
  function actionTypeMap() {
    const ver = (state.actionTypes || []).length;
    if (_actionTypeMapCache === null || _actionTypeMapVersion !== ver) {
      _actionTypeMapCache = new Map((state.actionTypes || []).map((at) => [at.id, at]));
      _actionTypeMapVersion = ver;
    }
    return _actionTypeMapCache;
  }
  function invalidateActionTypeCache() { _actionTypeMapCache = null; }
  function getActionType(id) {
    const up = String(id || "").toUpperCase();
    return actionTypeMap().get(up) || state.actionTypes?.[0] || normalizeActionType({ id: "IDLE" });
  }

  // ----- State -----
  function defaultState() {
    const st1 = { id: uuid(), code: "S01", name: "Assembly Line A - Station 1" };
    const job1 = {
      id: uuid(), stationId: st1.id,
      name: "Pick / Place / Machine",
      allowancePct: 12, ratingPct: 100,
      elements: [
        { id: uuid(), name: "Pick part", type: "HUMAN" },
        { id: uuid(), name: "Place part", type: "HUMAN" },
        { id: uuid(), name: "Machine cycle", type: "MACHINE" },
      ],
      cycles: []
    };
    return {
      meta: { createdAt: wallIso(), updatedAt: wallIso() },
      activeJobId: job1.id,
      stations: [st1],
      jobs: [job1],
      actionTypes: defaultActionTypes(),
      ui: defaultUiState(),
    };
  }

  let state = loadState();
  let lastStateSignature = JSON.stringify(state);
  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return defaultState();
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.stations) || !Array.isArray(parsed.jobs)) return defaultState();
      if (!parsed.activeJobId && parsed.jobs[0]) parsed.activeJobId = parsed.jobs[0].id;

      if (parsed.stations.length > 0) {
        for (const j of parsed.jobs) if (!j.stationId) j.stationId = parsed.stations[0].id;
      }
      for (const j of parsed.jobs) {
        if (!Array.isArray(j.cycles)) j.cycles = [];
        for (const c of j.cycles) {
          if (!c.tag) c.tag = "Normal";
          if (c.note == null) c.note = "";
        }
      }
      ensureActionTypes(parsed);
      ensureUiState(parsed);
      return parsed;
    } catch {
      return defaultState();
    }
  }
  function saveState() {
    state.meta.updatedAt = wallIso();
    const raw = JSON.stringify(state);
    localStorage.setItem(STORAGE_KEY, raw);
    lastStateSignature = raw;
    flashSavePill("✓ Saved");
  }
  function flashSavePill(msg) {
    const p = $("savePill"); if (!p) return;
    p.textContent = msg;
    p.classList.add("vis");
    clearTimeout(p._t);
    p._t = setTimeout(() => p.classList.remove("vis"), 1800);
  }

  function getStationById(id){ return state.stations.find(s=>s.id===id) || null; }
  function getActiveJob(){ return state.jobs.find(j=>j.id===state.activeJobId) || null; }

  let selectedElementId = null;
  let selectedCycleId = null;
  let openInlineCycleIds = new Set();
  let selectedCycleIdsForLine = new Set();
  let searchText = "";
  let editingActionTypeId = null; // null when creating new, else original id when editing
  const addTypeBtn = $("addActionTypeBtn");
  function updateAddTypeButton() {
    if (!addTypeBtn) return;
    addTypeBtn.textContent = editingActionTypeId ? "Save" : "+ Type";
  }
  let graphMode = "SELECTED"; // SELECTED | ALL
  let captureMode = "continuous"; // continuous | single | video
  let singleCaptureElementId = "";
  const videoCapture = {
    url: "",
    markers: [], // { id, elementId, startSec, endSec }
    openByElementId: {}, // elementId -> markerId (open start)
    selectedElementId: "",
    editMarkerId: "",
  };
  let videoDrag = null; // { markerId, mode, x0, s0, e0, dur }
  const timelineEditState = {
    geom: null, // { padL, padR, padT, padB, cw, ch, xMaxSec, hits: [] }
    drag: null, // { cycleId, elementId, x0, initialMs, mode }
    lastDragTs: 0,
    editor: { open: false, cycleId: "", elementId: "", x: 0, y: 0, manualPos: false, lastField: "" },
    editorDrag: null,
  };

  // ----- Drawer -----
  const root = $("drawerRoot");
  function openDrawer(){ root.classList.add("open"); }
  function closeDrawer(){ root.classList.remove("open"); }
  function applyDrawerSectionsUi() {
    ensureUiState(state);
    const map = state.ui.drawerSections || {};
    document.querySelectorAll("#drawerBody .drawerSection[data-drawer-sec]").forEach((sec) => {
      const id = String(sec.dataset.drawerSec || "");
      const open = map[id] !== false;
      sec.classList.toggle("collapsed", !open);
      const btn = sec.querySelector("[data-drawer-sec-btn]");
      if (btn) btn.setAttribute("aria-expanded", open ? "true" : "false");
    });
  }

  function toHex6(v, fallback) {
    const s = String(v || "");
    return /^#[0-9a-fA-F]{6}$/.test(s) ? s : fallback;
  }

  function hexToRgba(hex, alpha = 1) {
    const h = toHex6(hex, "#000000");
    const r = parseInt(h.slice(1, 3), 16);
    const g = parseInt(h.slice(3, 5), 16);
    const b = parseInt(h.slice(5, 7), 16);
    const a = Math.max(0, Math.min(1, Number(alpha) || 1));
    return `rgba(${r}, ${g}, ${b}, ${a})`;
  }

  function applyThemeUi() {
    ensureUiState(state);
    const bg = toHex6(state.ui.themeBg, "#0b0c10");
    const text = toHex6(state.ui.themeText, "#e8e8e8");
    const accent = toHex6(state.ui.themeAccent, "#4c73ff");
    // Detect light vs dark by bg luminance
    const r=parseInt(bg.slice(1,3),16), g=parseInt(bg.slice(3,5),16), b=parseInt(bg.slice(5,7),16);
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    const isLight = lum > 0.5;
    document.body.classList.toggle("themeLight", isLight);
    const rs = document.documentElement.style;
    rs.setProperty("--bg", bg);
    rs.setProperty("--text", text);
    rs.setProperty("--accent", accent);
    rs.setProperty("--accent-10", hexToRgba(accent, 0.10));
    rs.setProperty("--accent-18", hexToRgba(accent, 0.18));
    rs.setProperty("--accent-35", hexToRgba(accent, 0.35));
    rs.setProperty("--accent-55", hexToRgba(accent, 0.55));
    rs.setProperty("--accent-65", hexToRgba(accent, 0.65));
    rs.setProperty("--accent-75", hexToRgba(accent, 0.75));
    rs.setProperty("--accent-85", hexToRgba(accent, 0.85));
    if (isLight) {
      // Derive panel/border/muted from bg for light themes
      rs.setProperty("--panel", hexToRgba(bg, 1).replace("1)", "1)").replace("rgba","rgba").replace(/,\s*1\)/, ", 1)") + ""); 
      // Simpler: compute slightly darker panel from bg
      const darken = (hex, amt) => {
        let rr=parseInt(hex.slice(1,3),16), gg=parseInt(hex.slice(3,5),16), bb=parseInt(hex.slice(5,7),16);
        rr=Math.max(0,rr-amt); gg=Math.max(0,gg-amt); bb=Math.max(0,bb-amt);
        return "#"+[rr,gg,bb].map(x=>x.toString(16).padStart(2,"0")).join("");
      };
      rs.setProperty("--panel", darken(bg, 6));
      rs.setProperty("--panel2", darken(bg, 12));
      rs.setProperty("--border", "rgba(0,0,0,.13)");
      rs.setProperty("--muted", "rgba(0,0,0,.55)");
      rs.setProperty("--muted2", "rgba(0,0,0,.38)");
    } else {
      // Restore dark defaults derived from bg
      const lighten = (hex, amt) => {
        let rr=parseInt(hex.slice(1,3),16), gg=parseInt(hex.slice(3,5),16), bb=parseInt(hex.slice(5,7),16);
        rr=Math.min(255,rr+amt); gg=Math.min(255,gg+amt); bb=Math.min(255,bb+amt);
        return "#"+[rr,gg,bb].map(x=>x.toString(16).padStart(2,"0")).join("");
      };
      rs.setProperty("--panel", lighten(bg, 8));
      rs.setProperty("--panel2", lighten(bg, 4));
      rs.setProperty("--border", lighten(bg, 20));
      rs.setProperty("--muted", hexToRgba(text, 0.75));
      rs.setProperty("--muted2", hexToRgba(text, 0.55));
    }
    const hdr = document.querySelector("header");
    if (hdr) hdr.style.background = hexToRgba(bg, 0.92);
  }

  function accentRgba(alpha = 1) {
    const a = toHex6(state?.ui?.themeAccent, "#4c73ff");
    return hexToRgba(a, alpha);
  }
  function syncViewLayoutInputs() {
    ensureUiState(state);
    const modeSel = $("uiLayoutModeSel");
    if (modeSel) modeSel.value = state.ui.layoutMode;
    const panelLayoutSel = $("uiPanelLayoutSel");
    if (panelLayoutSel) panelLayoutSel.value = state.ui.panelLayout === "grid" ? "grid" : "stack";
    const quickPanelLayoutSel = $("quickPanelLayoutSel");
    if (quickPanelLayoutSel) quickPanelLayoutSel.value = state.ui.panelLayout === "grid" ? "grid" : "stack";
    const colsWrap = $("uiPanelGridColsWrap");
    if (colsWrap) colsWrap.style.display = state.ui.panelLayout === "grid" ? "" : "none";
    const colsRange = $("uiPanelGridColsRange");
    if (colsRange) colsRange.value = String(Math.max(1, Math.min(4, Number(state.ui.panelGridCols) || 2)));
    const colsValue = $("uiPanelGridColsValue");
    if (colsValue) colsValue.textContent = `${Math.max(1, Math.min(4, Number(state.ui.panelGridCols) || 2))} ${t("uiPanelGridColsValue", "cols")}`;
    const widthRange = $("uiJobsWidthRange");
    if (widthRange) widthRange.value = String(Math.round(state.ui.jobsPanelWidth));
    const widthLabel = $("uiJobsWidthLabel");
    if (widthLabel) widthLabel.textContent = `${Math.round(state.ui.jobsPanelWidth)} px`;
    const bg = $("uiBgColor");
    if (bg) bg.value = toHex6(state.ui.themeBg, "#0b0c10");
    const text = $("uiTextColor");
    if (text) text.value = toHex6(state.ui.themeText, "#e8e8e8");
    const accent = $("uiAccentColor");
    if (accent) accent.value = toHex6(state.ui.themeAccent, "#4c73ff");
    const unitSel = $("uiTimeUnitSel");
    if (unitSel) unitSel.value = timeUnit();
    const resSel = $("uiTimeResolutionSel");
    if (resSel) resSel.value = String(timeResolutionSec());
  }

  function setUiScale(scale) {
    const v = Math.max(0.2, Math.min(2, Number(scale || 1) || 1));
    state.ui.uiScale = v;
    document.documentElement.style.setProperty("--ui-scale", String(v));
    const inp = $("uiScaleInput");
    const rng = $("uiScaleRange");
    if (inp) inp.value = v.toFixed(2).replace(/0+$/, "").replace(/\.$/, "");
    if (rng) rng.value = String(Math.round(v * 100));
  }

  function setPanelVisible(name, visible, save = true) {
    if (!state.ui?.panels) return;
    state.ui.panels[name] = !!visible;
    applyUiLayout();
    if (save) saveState();
  }

  function reorderPanels(dragId, dropId) {
    if (!state.ui?.panelOrder) return;
    const src = String(dragId || "");
    const dst = String(dropId || "");
    if (!src || !dst || src === dst) return;
    const arr = state.ui.panelOrder.slice();
    const si = arr.indexOf(src);
    const di = arr.indexOf(dst);
    if (si < 0 || di < 0) return;
    arr.splice(si, 1);
    arr.splice(di, 0, src);
    state.ui.panelOrder = arr;
    applyUiLayout();
    saveState();
  }

  function applyUiLayout() {
    ensureUiState(state);
    applyThemeUi();
    setUiScale(state.ui.uiScale);
    syncViewLayoutInputs();
    document.body.classList.toggle("sidebarHidden", !state.ui.leftPanelVisible);
    document.body.classList.toggle("videoMode", captureMode === "video");
    const leftSec = $("leftPanelSection");
    if (leftSec) leftSec.style.display = state.ui.leftPanelVisible ? "" : "none";
    if (leftSec) leftSec.classList.toggle("collapsed", !!state.ui.jobsPanelCollapsed);
    const rightSec = $("rightMainSection");
    if (rightSec) rightSec.style.display = "";

    const layout = document.querySelector("main.layout");
    if (layout) {
      const desktop = window.matchMedia("(min-width: 1040px)").matches;
      const horizontal = desktop && state.ui.leftPanelVisible && state.ui.layoutMode !== "vertical";
      
      // Get the width from your settings
      const jobsW = Math.max(240, Math.min(640, Number(state.ui.jobsPanelWidth) || 360));
      
      if (horizontal) {
        layout.style.display = "grid";
        layout.style.gridTemplateColumns = `${jobsW}px minmax(0, 1fr)`; 
      } else {
        layout.style.gridTemplateColumns = "1fr";
      }
    }

    const timerOn = !!state.ui.panels.timer;
    const kpiOn = !!state.ui.panels.kpi;
    const timelineOn = !!state.ui.panels.timeline;
    const cyclesOn = !!state.ui.panels.cycles;
    const timerCard = $("panelTimerBlock");
    const kpiCard = $("panelKpiBlock");
    const timelineBlock = $("panelTimelineBlock");
    const cyclesBlock = $("panelCyclesBlock");
    if (timerCard) timerCard.style.display = timerOn ? "" : "none";
    if (kpiCard) kpiCard.style.display = kpiOn ? "" : "none";
    if (timelineBlock) timelineBlock.style.display = timelineOn ? "" : "none";
    if (cyclesBlock) cyclesBlock.style.display = cyclesOn ? "" : "none";

    const panelDock = $("panelDock");
    if (panelDock) {
      panelDock.classList.toggle("panelLayoutGrid", state.ui.panelLayout === "grid");
      panelDock.style.setProperty("--panel-grid-cols", String(Math.max(1, Math.min(4, Number(state.ui.panelGridCols) || 2))));
    }

    const blockMap = {
      timer: $("panelTimerBlock"),
      kpi: $("panelKpiBlock"),
      timeline: $("panelTimelineBlock"),
      cycles: $("panelCyclesBlock"),
    };
    (state.ui.panelOrder || []).forEach((panel, idx) => {
      const b = blockMap[panel];
      if (b) b.style.order = String(idx);
      document.querySelectorAll(`[data-panel-toggle="${panel}"]`).forEach((btn) => btn.style.order = String(idx));
      document.querySelectorAll(`[data-ui-panel="${panel}"]`).forEach((btn) => btn.style.order = String(idx));
    });

    const leftBtn = $("toggleLeftPanelBtn");
    if (leftBtn) leftBtn.textContent = state.ui.leftPanelVisible ? t("hideJobs", "Hide Jobs") : t("showJobs", "Show Jobs");

    const syncBtnState = (selector, panel) => {
      document.querySelectorAll(selector).forEach((btn) => {
        const on = !!state.ui.panels[panel];
        btn.classList.toggle("active", on);
      });
    };
    document.querySelectorAll('[data-panel-toggle="jobs"]').forEach((btn) => {
      btn.classList.toggle("active", !!state.ui.leftPanelVisible);
      btn.textContent = t("jobs", "Jobs");
    });
    syncBtnState('[data-panel-toggle="timer"]', "timer");
    syncBtnState('[data-panel-toggle="kpi"]', "kpi");
    syncBtnState('[data-panel-toggle="timeline"]', "timeline");
    syncBtnState('[data-panel-toggle="cycles"]', "cycles");
    syncBtnState('[data-ui-panel="timer"]', "timer");
    syncBtnState('[data-ui-panel="kpi"]', "kpi");
    syncBtnState('[data-ui-panel="timeline"]', "timeline");
    syncBtnState('[data-ui-panel="cycles"]', "cycles");
  }

  function fmtSec(sec) {
    const ms = Math.max(0, Number(sec || 0) * 1000);
    return fmtMs(ms);
  }

  function currentJobElements() {
    const job = getActiveJob();
    return job?.elements || [];
  }

  function ensureCaptureSelection() {
    const els = currentJobElements();
    if (!els.length) {
      singleCaptureElementId = "";
      return;
    }
    if (!singleCaptureElementId || !els.some((e) => e.id === singleCaptureElementId)) {
      singleCaptureElementId = els[0].id;
    }
  }

  function renderCaptureSelectors() {
    const job = getActiveJob();
    const singleSel = $("singleActionSel");
    const videoText = $("videoActionText");
    const videoBtns = $("videoActionBtns");
    const elements = job?.elements || [];
    ensureCaptureSelection();
    if (!videoCapture.selectedElementId || !elements.some((e) => e.id === videoCapture.selectedElementId)) {
      videoCapture.selectedElementId = elements[0]?.id || "";
    }

    if (singleSel) {
      singleSel.innerHTML = "";
      for (const el of elements) {
        const opt = document.createElement("option");
        opt.value = el.id;
        opt.textContent = `${el.name} (${el.type})`;
        singleSel.appendChild(opt);
      }
      if (singleCaptureElementId) singleSel.value = singleCaptureElementId;
      singleSel.disabled = !elements.length;
    }
    if (videoText) {
      const activeEl = elements.find((el) => el.id === videoCapture.selectedElementId);
      videoText.textContent = activeEl ? `${activeEl.name} (${activeEl.type})` : "-";
    }
    if (videoBtns) {
      const active = String(videoCapture.selectedElementId || "");
      videoBtns.innerHTML = "";
      for (const el of elements) {
        const at = getActionType(el.type);
        const b = document.createElement("button");
        b.type = "button";
        b.className = "videoActionBtn" + (el.id === active ? " active" : "");
        b.textContent = el.name;
        b.style.borderColor = at.color || "#4c73ff";
        b.style.boxShadow = `inset 0 0 0 1px ${at.color || "#4c73ff"}55`;
        b.addEventListener("click", () => {
          videoCapture.selectedElementId = el.id;
          renderCaptureSelectors();
        });
        videoBtns.appendChild(b);
      }
    }
    populateVideoLibrarySelector();
  }

  function refreshCaptureModeUI() {
    const modeSel = $("captureModeSel");
    captureMode = String(modeSel?.value || "continuous");
    const isSingle = captureMode === "single";
    const isVideo = captureMode === "video";
    document.body.classList.toggle("videoMode", isVideo);
    $("singleActionWrap").style.display = isSingle ? "" : "none";
    $("videoCaptureWrap").style.display = isVideo ? "" : "none";
    const mainBtn = $("mainBtn");
    if (mainBtn) mainBtn.style.display = isVideo ? "none" : "";
    const finishBtn = $("finishCycleBtn");
    if (finishBtn) finishBtn.style.display = isVideo ? "none" : "";
    const undoBtn = $("undoBtn");
    if (undoBtn) undoBtn.style.display = isVideo ? "none" : "";
    const hint = $("timerKeyboardHint");
    if (hint) hint.style.display = isVideo ? "none" : "";
    if (isSingle) ensureCaptureSelection();
    if (timer.mode === TimerMode.Running && timer.captureMode !== captureMode) {
      stopCycle();
    }
  }

  // ----- Timer -----
  const TimerMode = { Idle:"IDLE", Running:"RUNNING" };
  let timer = { mode:TimerMode.Idle, startPerf:0, lastMarkPerf:0, laps:[], index:0, captureMode:"continuous", singleElementId:"" };
  let raf = null;

  function startCycle() {
    const job = getActiveJob();
    if (!job) return alert(t("selectJob", "Select a job first."));
    if (job.elements.length === 0) return alert(t("addElementsInConfig", "Add at least 1 element first."));
    refreshCaptureModeUI();
    if (captureMode === "video") return alert(t("videoHint", "Video mode uses markers. Use \"Create cycle from markers\"."));
    ensureCaptureSelection();
    timer.mode = TimerMode.Running;
    timer.captureMode = captureMode;
    timer.singleElementId = singleCaptureElementId;
    timer.startPerf = perfNow();
    timer.lastMarkPerf = timer.startPerf;
    timer.laps = [];
    timer.index = Math.max(0, job.elements.findIndex((e) => e.id === timer.singleElementId));
    if (timer.captureMode === "continuous") timer.index = 0;
    $("elapsed").textContent = "00:00.000";
    tick();
    renderAll();
  }

  function commitLapAndAdvance(isFinishing=false) {
    const job = getActiveJob();
    if (!job || timer.mode !== TimerMode.Running) return;

    let el = null;
    if (timer.captureMode === "single") {
      el = job.elements.find((x) => x.id === timer.singleElementId) || job.elements[0];
    } else {
      const idx = Math.min(timer.index, job.elements.length - 1);
      el = job.elements[idx];
    }
    if (!el) return;
    const t = perfNow();
    const ms = quantizeMs(t - timer.lastMarkPerf);

    timer.laps.push({ elementId: el.id, name: el.name, type: el.type, ms });
    timer.lastMarkPerf = t;

    if (isFinishing) {
      const totalMs = quantizeMs(t - timer.startPerf);
      const cycle = { id: uuid(), atIso: wallIso(), laps: timer.laps, totalMs, tag:"Normal", note:"" };
      job.cycles.push(cycle);

      selectedCycleId = cycle.id;
      selectedCycleIdsForLine.add(cycle.id);
      boundLineSelection(job, 6);

      saveState();
      stopCycle();
      renderAll();
      return;
    }

    if (timer.captureMode === "continuous") {
      timer.index = Math.min(timer.index + 1, job.elements.length - 1);
    }
    renderAll();
  }

  function stopCycle() {
    timer.mode = TimerMode.Idle;
    timer.laps = [];
    timer.index = 0;
    if (raf) cancelAnimationFrame(raf);
    raf = null;
    renderAll();
  }

  function undoLap() {
    if (timer.mode !== TimerMode.Running) return;
    if (timer.laps.length === 0) return;
    timer.laps.pop();
    if (timer.captureMode === "continuous") timer.index = Math.max(timer.index - 1, 0);
    timer.lastMarkPerf = perfNow();
    renderAll();
  }

  function tick() {
    if (timer.mode !== TimerMode.Running) return;
    $("elapsed").textContent = fmtMs(perfNow() - timer.startPerf);
    raf = requestAnimationFrame(tick);
  }

  function loadVideoBookmarksLibrary() {
    try {
      const raw = localStorage.getItem(VIDEO_BOOKMARKS_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return [];
      return arr.filter((x) => x && Array.isArray(x.bookmarks));
    } catch {
      return [];
    }
  }

  function saveVideoBookmarksLibrary(entries) {
    const list = Array.isArray(entries) ? entries : [];
    localStorage.setItem(VIDEO_BOOKMARKS_KEY, JSON.stringify(list.slice(0, 200)));
  }

  function populateVideoLibrarySelector() {
    const sel = $("videoLibSel");
    if (!sel) return;
    const prev = String(sel.value || "");
    const entries = loadVideoBookmarksLibrary().slice().sort((a, b) => {
      const ta = Date.parse(a.createdAt || "") || 0;
      const tb = Date.parse(b.createdAt || "") || 0;
      return tb - ta;
    });
    sel.innerHTML = `<option value="">(none)</option>`;
    for (const e of entries) {
      const id = String(e.id || "");
      const title = String(e.title || e.jobName || "Recorded video");
      const t = e.createdAt ? new Date(e.createdAt).toLocaleString() : "";
      const cnt = Array.isArray(e.bookmarks) ? e.bookmarks.length : 0;
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = `${title} · ${cnt} marks${t ? " · " + t : ""}`;
      sel.appendChild(opt);
    }
    if (prev && [...sel.options].some((o) => o.value === prev)) sel.value = prev;
  }

  function resolveEntryElementId(entryMark, job, fallbackIndex) {
    const elements = (job?.elements || []);
    const byId = new Map(elements.map((el) => [String(el.id), el.id]));
    const byName = new Map(elements.map((el) => [String(el.name || "").trim().toLowerCase(), el.id]));
    const directId = String(entryMark?.elementId || "");
    if (directId && byId.has(directId)) return byId.get(directId);
    const nm = String(entryMark?.name || "").trim().toLowerCase();
    if (nm && byName.has(nm)) return byName.get(nm);
    if (fallbackIndex >= 0 && fallbackIndex < elements.length) return elements[fallbackIndex].id;
    return "";
  }

  function loadVideoLibraryEntryIntoMarkers(entryId) {
    const id = String(entryId || "");
    if (!id) return;
    const entries = loadVideoBookmarksLibrary();
    const entry = entries.find((e) => String(e.id || "") === id);
    if (!entry) return alert("Video bookmarks entry not found.");
    const job = getActiveJob();
    if (!job || !job.elements?.length) return alert("Select a job with elements first.");
    const marks = Array.isArray(entry.bookmarks) ? entry.bookmarks : [];
    const loaded = [];
    for (let i = 0; i < marks.length; i++) {
      const m = marks[i] || {};
      const startMs = Math.max(0, Number(m.startMs || 0));
      const endMs = Math.max(startMs, Number(m.endMs || startMs));
      const elementId = resolveEntryElementId(m, job, i);
      if (!elementId) continue;
      loaded.push({
        id: uuid(),
        elementId,
        startSec: quantizeSec(startMs / 1000),
        endSec: quantizeSec(endMs / 1000),
      });
    }
    if (!loaded.length) return alert("No compatible bookmarks for current job.");
    videoCapture.markers = loaded;
    videoCapture.openByElementId = {};
    videoCapture.editMarkerId = "";
    renderVideoMarkersList();
    syncVideoTimeline();
    alert(`Loaded ${loaded.length} bookmark(s). Load the matching video file if needed.`);
  }

  function loadVideoFile(file) {
    const video = $("videoEl");
    if (!video || !file) return;
    if (videoCapture.url) URL.revokeObjectURL(videoCapture.url);
    videoCapture.url = URL.createObjectURL(file);
    video.src = videoCapture.url;
    video.load();
    syncVideoTimeline();
  }

  function syncVideoTimeline() {
    const video = $("videoEl");
    const range = $("videoTimeline");
    const lbl = $("videoTimelineLabel");
    if (!video || !range || !lbl) return;
    const dur = Number.isFinite(video.duration) ? Math.max(0, video.duration) : 0;
    const cur = Math.max(0, Math.min(dur || Number(video.currentTime || 0), Number(video.currentTime || 0)));
    range.max = String(dur);
    range.value = String(cur);
    range.disabled = dur <= 0;
    lbl.textContent = `${fmtSec(cur)} / ${fmtSec(dur)}`;
    renderVideoLaneBars();
  }

  function sortedVideoMarkers() {
    return videoCapture.markers.slice().sort((a, b) => (a.startSec ?? 0) - (b.startSec ?? 0));
  }

  function getResolvedVideoMarkers(job, includeOpen = true) {
    const markers = sortedVideoMarkers();
    const byId = new Map((job?.elements || []).map((el) => [el.id, el]));
    const useRules = !!$("videoStackRulesChk")?.checked;
    const resourceEnd = new Map();
    const typeEnd = new Map();
    const out = [];

    for (const m of markers) {
      const el = byId.get(m.elementId);
      if (!el) continue;
      const at = getActionType(el.type);
      const typeId = String(at.id || el.type || "").toUpperCase();
      const laneId = String(at.lane || "lane");
      const depType = String(at.underlayTypeId || "").toUpperCase();

      let s = Number(m.startSec || 0);
      let e = (m.endSec == null) ? null : Number(m.endSec || 0);
      if (e != null && e < s) {
        const tmp = s;
        s = e;
        e = tmp;
      }
      const open = e == null;
      if (open && !includeOpen) continue;
      const dur = Math.max(0, (e ?? s) - s);
      const origStart = s;
      let waitSec = 0;

      if (useRules) {
        const resources = getActionResourceKeys(typeId, laneId);
        const laneBlock = resources.reduce((mx, rk) => Math.max(mx, Number(resourceEnd.get(rk) || 0)), 0);
        const depBlock = depType ? Number(typeEnd.get(depType) || 0) : 0;
        const blockAt = Math.max(laneBlock, depBlock);
        if (s < blockAt) {
          waitSec = blockAt - s;
          s = blockAt;
        }
      }

      if (open) {
        e = null;
      } else {
        e = s + dur;
      }

      if (useRules) {
        const endForRules = Number(e ?? s);
        const resources = getActionResourceKeys(typeId, laneId);
        for (const rk of resources) {
          resourceEnd.set(rk, Math.max(Number(resourceEnd.get(rk) || 0), endForRules));
        }
        typeEnd.set(typeId, Math.max(Number(typeEnd.get(typeId) || 0), endForRules));
      }

      out.push({
        id: m.id,
        elementId: m.elementId,
        name: el.name,
        type: el.type,
        lane: laneId,
        color: at.color || "#4c73ff",
        startSec: s,
        endSec: e,
        open,
        waitSec,
        sourceStartSec: origStart,
      });
    }
    return out;
  }

  function updateVideoWaitInfo(resolvedMarkers) {
    const info = $("videoWaitInfo");
    if (!info) return;
    const waitSec = (resolvedMarkers || []).reduce((acc, m) => acc + Number(m.waitSec || 0), 0);
    info.textContent = `${t("wait", "Wait")}: ${fmtQtySec(waitSec)}`;
  }

  function renderVideoMarkersList() {
    const box = $("videoMarkersList");
    const job = getActiveJob();
    if (!box) return;
    if (!videoCapture.markers.length) {
      box.textContent = t("noMarkers", "No markers");
      updateVideoWaitInfo([]);
      renderVideoLaneBars();
      return;
    }
    const byId = new Map((job?.elements || []).map((el) => [el.id, el]));
    const resolved = getResolvedVideoMarkers(job, true);
    const resolvedById = new Map(resolved.map((x) => [x.id, x]));
    updateVideoWaitInfo(resolved);
    const video = $("videoEl");
    const dur = Number.isFinite(video?.duration) ? Math.max(0, video.duration) : 0;
    const rows = sortedVideoMarkers().map((m, i) => {
      const el = byId.get(m.elementId);
      const name = el ? `${el.name} (${el.type})` : m.elementId;
      const rx = resolvedById.get(m.id);
      const s = Number(m.startSec || 0);
      const e = m.endSec == null ? null : Number(m.endSec);
      const durTxt = e == null ? "--" : fmtQtySec(Math.max(0, e - s));
      const waitTxt = Number(rx?.waitSec || 0) > 0 ? fmtQtySec(Number(rx.waitSec || 0)) : "-";
      const qStep = timeResolutionSec();
      const secDec = timeDecimals("s");
      const maxAttr = dur > 0 ? `max="${dur.toFixed(secDec)}"` : "";
      return `
        <tr>
          <td class="mono">${i + 1}</td>
          <td>${esc(name)}</td>
          <td><input class="videoNum mono" type="number" step="${qStep}" min="0" ${maxAttr} value="${s.toFixed(secDec)}" data-vs="${esc(m.id)}" /></td>
          <td><input class="videoNum mono" type="number" step="${qStep}" min="0" ${maxAttr} value="${e == null ? "" : e.toFixed(secDec)}" data-ve="${esc(m.id)}" placeholder="end" /></td>
          <td class="mono">${durTxt}</td>
          <td class="mono">${waitTxt}</td>
          <td>
            <div class="videoAdjustBtns">
              <button class="videoMiniBtn mono" type="button" data-vns="${esc(m.id)}">S<-Now</button>
              <button class="videoMiniBtn mono" type="button" data-vne="${esc(m.id)}">E<-Now</button>
              <button class="videoMiniBtn danger mono" type="button" data-vdel="${esc(m.id)}">Del</button>
            </div>
          </td>
        </tr>
      `;
    }).join("");
    box.innerHTML = `
      <div class="scrollBox videoMarkersBox">
        <table class="videoMarkersTable">
          <thead>
            <tr>
              <th style="width:40px;">#</th>
              <th>Action</th>
              <th style="width:98px;">Start s</th>
              <th style="width:98px;">End s</th>
              <th style="width:92px;">Dur</th>
              <th style="width:92px;">Wait</th>
              <th style="width:210px;">Adjust</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>
    `;
    renderVideoLaneBars();
  }

  function renderVideoLaneBars() {
    const wrap = $("videoLaneBars");
    const video = $("videoEl");
    const job = getActiveJob();
    if (!wrap || !video || !job) return;
    const dur = Number.isFinite(video.duration) ? Math.max(0, Number(video.duration)) : 0;
    if (dur <= 0) {
      wrap.innerHTML = `<div class="small muted">${esc(t("videoFile", "Load a video file first."))}</div>`;
      return;
    }
    const now = Math.max(0, Math.min(dur, Number(video.currentTime || 0)));
    const resolved = getResolvedVideoMarkers(job, true);
    const typeOrder = [];
    const seenTypes = new Set();
    for (const el of (job.elements || [])) {
      const tid = String(el.type || "").toUpperCase();
      if (!tid || seenTypes.has(tid)) continue;
      seenTypes.add(tid);
      typeOrder.push(tid);
    }
    if (!typeOrder.length) {
      wrap.innerHTML = `<div class="small muted">${esc(t("noMarkers", "No markers"))}</div>`;
      return;
    }
    let html = `<div class="videoLaneGrid">`;
    for (const typeId of typeOrder) {
      const atType = getActionType(typeId);
      const rowLabel = atType?.name ? `${typeId}` : typeId;
      html += `<div class="videoLaneLabel mono">${esc(rowLabel)}</div><div class="videoLaneTrack">`;
      for (const m of resolved) {
        if (String(m.type || "").toUpperCase() !== typeId) continue;
        const s = Math.max(0, Math.min(dur, Number(m.startSec || 0)));
        const e = m.open ? now : Math.max(s, Math.min(dur, Number(m.endSec || s)));
        const left = (s / dur) * 100;
        const width = Math.max(0.2, ((e - s) / dur) * 100);
        const editCls = videoCapture.editMarkerId === m.id ? " editing" : "";
        const mType = String(m.type || "").toUpperCase();
        const mRoles = actionRoleFlags(mType);
        const isMachineBox = !!mRoles.machineOnly;
        const withMachineOverlay = !!(mRoles.machine && !isMachineBox);
        const styleBg = isMachineBox ? "" : `background:${esc(m.color || "#4c73ff")};`;
        html += `<span class="videoSeg${m.open ? " open" : ""}${editCls}${isMachineBox ? " machineBox" : ""}${withMachineOverlay ? " withMachineOverlay" : ""}" data-mid="${esc(m.id)}" title="${esc(m.name)} ${fmtSec(s)} - ${m.open ? "..." : fmtSec(e)}" style="left:${left}%;width:${width}%;${styleBg}">
          ${withMachineOverlay ? '<span class="videoSegOverlay"></span>' : ''}
          <span class="videoSegHandle start" data-mid="${esc(m.id)}" data-handle="start"></span>
          <span class="videoSegHandle end" data-mid="${esc(m.id)}" data-handle="end"></span>
        </span>`;
      }
      const ph = (now / dur) * 100;
      html += `<span class="videoPlayhead" style="left:${ph}%"></span></div>`;
    }
    html += `</div>`;
    wrap.innerHTML = html;
  }

  function getVideoSelectedActionId() {
    return String(videoCapture.selectedElementId || "");
  }

  function getVideoSequenceElements() {
    const job = getActiveJob();
    return job?.elements || [];
  }

  function setVideoSelectedActionByIndex(idx) {
    const els = getVideoSequenceElements();
    if (!els.length) {
      videoCapture.selectedElementId = "";
      renderCaptureSelectors();
      return;
    }
    const nextIdx = ((idx % els.length) + els.length) % els.length;
    videoCapture.selectedElementId = els[nextIdx].id;
    renderCaptureSelectors();
  }

  function getVideoSelectedIndex() {
    const els = getVideoSequenceElements();
    if (!els.length) return -1;
    const sid = getVideoSelectedActionId();
    const idx = els.findIndex((el) => el.id === sid);
    return idx >= 0 ? idx : 0;
  }

  function videoMarkStart() {
    const job = getActiveJob();
    if (!job || !job.elements.length) return alert(t("addElementsInConfig", "Add at least 1 element first."));
    const actionId = getVideoSelectedActionId();
    if (!actionId) return alert(t("videoAction", "Select a video action."));
    const video = $("videoEl");
    if (!video?.src) return alert(t("videoFile", "Load a video file first."));
    const nowSec = quantizeSec(Number(video.currentTime || 0));

    const openId = videoCapture.openByElementId[actionId];
    if (openId) {
      const mk = videoCapture.markers.find((x) => x.id === openId);
      if (mk) {
        mk.startSec = quantizeSec(nowSec);
        mk.endSec = null;
      }
    } else {
      const id = uuid();
      videoCapture.markers.push({ id, elementId: actionId, startSec: quantizeSec(nowSec), endSec: null });
      videoCapture.openByElementId[actionId] = id;
    }
    renderVideoMarkersList();
  }

  function videoMarkEnd() {
    const job = getActiveJob();
    if (!job || !job.elements.length) return alert(t("addElementsInConfig", "Add at least 1 element first."));
    const actionId = getVideoSelectedActionId();
    if (!actionId) return alert(t("videoAction", "Select a video action."));
    const video = $("videoEl");
    if (!video?.src) return alert(t("videoFile", "Load a video file first."));
    const openId = videoCapture.openByElementId[actionId];
    if (!openId) return alert(t("markStart", "Mark start") + " first.");

    const nowSec = quantizeSec(Number(video.currentTime || 0));
    const mk = videoCapture.markers.find((x) => x.id === openId);
    if (mk) {
      mk.endSec = quantizeSec(nowSec);
      if (Number(mk.endSec) < Number(mk.startSec)) {
        const tmp = mk.startSec;
        mk.startSec = mk.endSec;
        mk.endSec = tmp;
      }
    }
    delete videoCapture.openByElementId[actionId];
    renderVideoMarkersList();
  }

  function videoSequenceStep() {
    const job = getActiveJob();
    if (!job || !job.elements.length) return alert(t("addElementsInConfig", "Add at least 1 element first."));
    const video = $("videoEl");
    if (!video?.src) return alert(t("videoFile", "Load a video file first."));
    if (!getVideoSelectedActionId()) setVideoSelectedActionByIndex(0);

    const currentId = getVideoSelectedActionId();
    const openId = videoCapture.openByElementId[currentId];
    if (!openId) {
      videoMarkStart();
      video.play?.().catch(() => {});
      return;
    }

    videoMarkEnd();
    const curIdx = getVideoSelectedIndex();
    const nextIdx = curIdx + 1;
    setVideoSelectedActionByIndex(nextIdx);
    videoMarkStart();
    video.play?.().catch(() => {});
  }

  function clearVideoMarkers() {
    videoCapture.markers = [];
    videoCapture.openByElementId = {};
    videoCapture.editMarkerId = "";
    renderVideoMarkersList();
  }

  function applyVideoAutoStack() {
    const job = getActiveJob();
    if (!job || !videoCapture.markers.length) return;
    const resolved = getResolvedVideoMarkers(job, true);
    const byId = new Map(resolved.map((x) => [x.id, x]));
    for (const mk of videoCapture.markers) {
      const rx = byId.get(mk.id);
      if (!rx) continue;
      mk.startSec = quantizeSec(Number(rx.startSec || 0));
      mk.endSec = rx.open ? null : quantizeSec(Number(rx.endSec || rx.startSec || 0));
    }
    videoCapture.openByElementId = {};
    renderVideoMarkersList();
    syncVideoTimeline();
  }

  function bindVideoBarInteractions() {
    const wrap = $("videoLaneBars");
    if (!wrap) return;
    wrap.addEventListener("dblclick", (e) => {
      const seg = e.target?.closest?.("[data-mid]");
      if (!seg) return;
      const id = String(seg.dataset.mid || "");
      videoCapture.editMarkerId = (videoCapture.editMarkerId === id) ? "" : id;
      renderVideoLaneBars();
    });
    wrap.addEventListener("pointerdown", (e) => {
      const target = e.target;
      const seg = target?.closest?.("[data-mid]");
      if (!seg) return;
      const stackChk = $("videoStackRulesChk");
      if (stackChk?.checked) {
        stackChk.checked = false;
      }
      const markerId = String(seg.dataset.mid || "");
      const mk = videoCapture.markers.find((x) => x.id === markerId);
      const video = $("videoEl");
      const dur = Number.isFinite(video?.duration) ? Math.max(0, Number(video.duration)) : 0;
      if (!mk || dur <= 0) return;
      const mode = (target?.dataset?.handle === "start" || target?.dataset?.handle === "end")
        ? String(target.dataset.handle)
        : "move";
      if ((mode === "start" || mode === "end") && videoCapture.editMarkerId !== markerId) return;
      const s0 = Number(mk.startSec || 0);
      const e0 = mk.endSec == null ? s0 : Number(mk.endSec || s0);
      videoDrag = { markerId, mode, x0: Number(e.clientX || 0), s0, e0, dur };
      try { target.setPointerCapture?.(e.pointerId); } catch {}
      e.preventDefault();
    });
  }

  function onVideoPointerMove(e) {
    if (!videoDrag) return;
    const wrap = $("videoLaneBars");
    if (!wrap) return;
    const mk = videoCapture.markers.find((x) => x.id === videoDrag.markerId);
    if (!mk) return;
    const rect = wrap.getBoundingClientRect();
    if (!rect.width) return;
    const secPerPx = videoDrag.dur / rect.width;
    const dxSec = (Number(e.clientX || 0) - videoDrag.x0) * secPerPx;
    const minSpan = timeResolutionSec();
    let s = videoDrag.s0;
    let eSec = videoDrag.e0;
    if (videoDrag.mode === "move") {
      const span = Math.max(minSpan, videoDrag.e0 - videoDrag.s0);
      s = Math.max(0, Math.min(videoDrag.dur - span, videoDrag.s0 + dxSec));
      eSec = s + span;
    } else if (videoDrag.mode === "start") {
      s = Math.max(0, Math.min(videoDrag.e0 - minSpan, videoDrag.s0 + dxSec));
      eSec = videoDrag.e0;
    } else if (videoDrag.mode === "end") {
      eSec = Math.max(videoDrag.s0 + minSpan, Math.min(videoDrag.dur, videoDrag.e0 + dxSec));
      s = videoDrag.s0;
    }
    mk.startSec = quantizeSec(s);
    mk.endSec = quantizeSec(eSec);
    renderVideoLaneBars();
  }

  function onVideoPointerUp() {
    if (!videoDrag) return;
    videoDrag = null;
    renderVideoMarkersList();
    syncVideoTimeline();
  }

  function applyVideoMarkersToCycle() {
    const job = getActiveJob();
    if (!job) return alert(t("selectJob", "Select a job first."));
    if (!videoCapture.markers.length) return alert(t("noMarkers", "No markers."));
    const resolved = getResolvedVideoMarkers(job, false);
    if (!resolved.length) return alert(t("noMarkers", "Markers do not contain valid start/end pairs."));
    const laps = [];
    for (const el of job.elements) {
      let ms = 0;
      for (const m of resolved) {
        if (m.elementId !== el.id || m.endSec == null) continue;
        const s = Number(m.startSec || 0);
        const e = Number(m.endSec || 0);
        const segMs = quantizeMs(Math.max(0, e - s) * 1000);
        ms += segMs;
      }
      if (ms > 0) laps.push({ elementId: el.id, name: el.name, type: el.type, ms: quantizeMs(ms) });
    }
    if (!laps.length) return alert(t("noMarkers", "Markers do not contain valid start/end pairs."));
    const tMin = Math.min(...resolved.map((m) => Number(m.startSec || 0)));
    const tMax = Math.max(...resolved.map((m) => Number(m.endSec || m.startSec || 0)));
    const totalMs = quantizeMs(Math.max(0, tMax - tMin) * 1000);
    const waitMs = quantizeMs(resolved.reduce((acc, m) => acc + (Number(m.waitSec || 0) * 1000), 0));
    const cycle = { id: uuid(), atIso: wallIso(), laps, totalMs, tag: "Normal", note: waitMs > 0 ? `Video markers - wait ${fmtQtyMs(waitMs)}` : "Video markers" };
    job.cycles.push(cycle);
    selectedCycleId = cycle.id;
    selectedCycleIdsForLine.add(cycle.id);
    boundLineSelection(job, 6);
    saveState();
    renderAll();
  }

  // ----- Stats / outliers -----
  function mean(arr){ return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : null; }
  function quantile(sortedArr, q) {
    const n = sortedArr.length;
    if (!n) return null;
    const pos = (n - 1) * q;
    const base = Math.floor(pos);
    const rest = pos - base;
    if (sortedArr[base+1] === undefined) return sortedArr[base];
    return sortedArr[base] + rest * (sortedArr[base+1] - sortedArr[base]);
  }
  function normalToStandardMs(job, observedMs) {
    const ratingFactor = Number(job.ratingPct) / 100;
    const allowanceFactor = 1 + (Number(job.allowancePct) / 100);
    return (observedMs * ratingFactor) * allowanceFactor;
  }
  function computeCycleStats(job, cycles) {
    const totals = (cycles || []).map((c) => quantizeMs(Number(c.totalMs || 0))).filter((v) => Number.isFinite(v) && v > 0);
    if (!totals.length) return null;
    const sorted = totals.slice().sort((a, b) => a - b);
    const avgMs = mean(totals);
    const medianMs = quantile(sorted, 0.5);
    const p90Ms = quantile(sorted, 0.9);
    const bestMs = sorted[0];
    const worstMs = sorted[sorted.length - 1];
    const varSum = totals.reduce((acc, x) => acc + Math.pow(x - avgMs, 2), 0);
    const stdevMs = Math.sqrt(varSum / totals.length);
    const cv = avgMs > 0 ? (stdevMs / avgMs) : 0;
    let stability = "No data";
    if (totals.length >= 3) {
      if (cv < 0.05) stability = "Very stable";
      else if (cv < 0.12) stability = "Stable";
      else if (cv < 0.22) stability = "Some variation";
      else stability = "Unstable";
    } else {
      stability = "Need more cycles";
    }
    return {
      count: totals.length,
      avgMs,
      medianMs,
      p90Ms,
      bestMs,
      worstMs,
      cv,
      throughputPerHour: avgMs > 0 ? (3600000 / avgMs) : null,
      stdMs: normalToStandardMs(job, avgMs),
      stability,
    };
  }

  function computeActionStats(job, cycles, avgCycleMs) {
    if (!job || !Array.isArray(job.elements) || !job.elements.length) return [];
    const cycleCount = Math.max(1, (cycles || []).length);
    const rows = [];
    for (const el of job.elements) {
      const vals = [];
      for (const c of (cycles || [])) {
        let ms = 0;
        for (const lap of (c.laps || [])) {
          if (lap.elementId === el.id) ms += quantizeMs(Number(lap.ms || 0));
        }
        vals.push(quantizeMs(ms));
      }
      if (!vals.length) continue;
      const avgMs = vals.reduce((a, b) => a + b, 0) / cycleCount;
      const minMs = Math.min(...vals);
      const maxMs = Math.max(...vals);
      const sharePct = avgCycleMs > 0 ? (avgMs / avgCycleMs) * 100 : 0;
      rows.push({
        id: el.id,
        name: el.name,
        type: el.type,
        avgMs,
        minMs,
        maxMs,
        sharePct,
      });
    }
    rows.sort((a, b) => b.avgMs - a.avgMs);
    return rows;
  }

  function selectedTagsSet() {
    const s = new Set();
    if ($("tagNormal").checked) s.add("Normal");
    if ($("tagRework").checked) s.add("Rework");
    if ($("tagTraining").checked) s.add("Training");
    if ($("tagDisturbance").checked) s.add("Disturbance");
    return s;
  }

  function perElementValues(job, cycles) {
    const map = new Map();
    for (const el of job.elements) map.set(el.id, []);
    for (const c of cycles) {
      const sums = new Map();
      for (const lap of c.laps) sums.set(lap.elementId, (sums.get(lap.elementId)||0) + quantizeMs(lap.ms));
      for (const el of job.elements) {
        const v = sums.get(el.id);
        if (v != null) map.get(el.id).push(v);
      }
    }
    return map;
  }

  function buildOutlierModel(job, cycles, mode) {
    const vals = perElementValues(job, cycles);
    const model = new Map();
    for (const el of job.elements) {
      const arrSec = (vals.get(el.id)||[]).map(x=>x/1000).sort((a,b)=>a-b);
      const avg = mean(arrSec) ?? 0;
      if (mode === "MULT_1_5") {
        model.set(el.id, { mode, avgSec: avg, hi: avg*1.5 });
      } else {
        const q1 = quantile(arrSec, 0.25) ?? 0;
        const q3 = quantile(arrSec, 0.75) ?? 0;
        const iqr = q3 - q1;
        model.set(el.id, { mode, avgSec: avg, lo: q1 - 1.5*iqr, hi: q3 + 1.5*iqr });
      }
    }
    return model;
  }

  // Job progress (same idea)
  function jobProgress(job) {
    // Smooth model:
    // setup quality (45) + sample maturity (35 up to 10 cycles) + stability (20)
    const elements = Number(job.elements?.length || 0);
    const cycles = Number(job.cycles?.length || 0);

    let setupScore = 0;
    if (elements > 0) setupScore += 25;
    if (elements >= 3) setupScore += 10;
    if (elements >= 5) setupScore += 10;

    const sampleScore = Math.max(0, Math.min(35, (Math.min(cycles, 10) / 10) * 35));

    let stabilityScore = 0;
    const stats = computeCycleStats(job, job.cycles || []);
    if (stats && stats.count >= 3) {
      const cv = Number(stats.cv || 0);
      if (cv <= 0.05) stabilityScore = 20;
      else if (cv <= 0.12) stabilityScore = 16;
      else if (cv <= 0.22) stabilityScore = 10;
      else stabilityScore = 5;
    }

    let score = Math.round(setupScore + sampleScore + stabilityScore);
    score = Math.max(0, Math.min(100, score));
    let level = "warn";
    if (score >= 85) level = "good";
    else if (score >= 60) level = "mid";
    return { score, level };
  }

  // ----- CRUD stations/jobs/elements -----
  function createStation() {
    const id = uuid();
    const code = prompt("Station ID / code (example: S03):", "S" + String(state.stations.length + 1).padStart(2,"0"));
    if (code === null) return;
    const name = prompt("Station name:", "New Station");
    if (name === null) return;
    state.stations.push({ id, code: code.trim() || "S??", name: name.trim() || "New Station" });
    saveState(); renderAll();
  }
  function renameStation(stationId) {
    const st = getStationById(stationId); if (!st) return;
    const code = prompt("Station code:", st.code); if (code === null) return;
    const name = prompt("Station name:", st.name); if (name === null) return;
    st.code = code.trim() || st.code;
    st.name = name.trim() || st.name;
    saveState(); renderAll();
  }
  function deleteStation(stationId) {
    const st = getStationById(stationId); if (!st) return;
    const jobsAtStation = state.jobs.filter(j => j.stationId === stationId).length;
    if (!confirm(`Delete station "${st.code} - ${st.name}"?\nDeletes ${jobsAtStation} job(s).`)) return;
    const active = getActiveJob();
    if (active && active.stationId === stationId && timer.mode === TimerMode.Running) stopCycle();
    state.jobs = state.jobs.filter(j => j.stationId !== stationId);
    state.stations = state.stations.filter(s => s.id !== stationId);
    if (!state.jobs.some(j => j.id === state.activeJobId)) state.activeJobId = state.jobs[0]?.id || null;
    saveState(); renderAll();
  }

  function selectJob(jobId) {
    if (timer.mode === TimerMode.Running) {
      if (!confirm("Timer running. Switch job and stop current cycle?")) return;
      stopCycle();
    }
    state.activeJobId = jobId;
    selectedElementId = null;
    selectedCycleId = null;
    selectedCycleIdsForLine = new Set();
    saveState();
    renderAll();
  }

  function createJob() {
    const stId = state.stations[0]?.id;
    if (!stId) return alert("Create a station first.");
    const id = uuid();
    state.jobs.unshift({ id, stationId: stId, name:"New job", allowancePct:12, ratingPct:100, elements:[], cycles:[] });
    state.activeJobId = id;
    selectedElementId = null; selectedCycleId = null; selectedCycleIdsForLine = new Set();
    saveState(); renderAll();
    openDrawer();
    $("jobName").focus(); $("jobName").select();
  }
  function duplicateActiveJob() {
    const job = getActiveJob(); if (!job) return;
    const id = uuid();
    const copy = {
      id, stationId: job.stationId,
      name: job.name + " (copy)",
      allowancePct: job.allowancePct,
      ratingPct: job.ratingPct,
      elements: job.elements.map(e => ({ id: uuid(), name: e.name, type: e.type })),
      cycles: []
    };
    state.jobs.unshift(copy);
    state.activeJobId = id;
    selectedElementId = null; selectedCycleId = null; selectedCycleIdsForLine = new Set();
    saveState(); renderAll();
    openDrawer();
  }
  function deleteActiveJob() {
    const job = getActiveJob(); if (!job) return;
    if (!confirm(`Delete job "${job.name}"? Removes cycles too.`)) return;
    if (timer.mode === TimerMode.Running) stopCycle();
    state.jobs = state.jobs.filter(j => j.id !== job.id);
    state.activeJobId = state.jobs[0]?.id || null;
    selectedElementId = null; selectedCycleId = null; selectedCycleIdsForLine = new Set();
    saveState(); renderAll();
  }

  function addElement() {
    const job = getActiveJob(); if (!job) return alert("Select a job first.");
    const name = $("elName").value.trim();
    const type = String($("elType").value || "").toUpperCase();
    if (!name) return alert("Element name required.");
    if (!actionTypeMap().has(type)) return alert(`Unknown action type: ${type}`);
    const el = { id: uuid(), name, type };
    job.elements.push(el);
    selectedElementId = el.id;
    $("elName").value = "";
    saveState(); renderAll();
  }
  function deleteSelectedElement() {
    const job = getActiveJob(); if (!job) return;
    if (!selectedElementId) return alert("Select an element row first.");
    const idx = job.elements.findIndex(e => e.id === selectedElementId);
    if (idx < 0) return;
    if (!confirm("Delete selected element?")) return;
    job.elements.splice(idx, 1);
    selectedElementId = null;
    saveState(); renderAll();
  }
  function moveSelectedElement(dir) {
    const job = getActiveJob(); if (!job) return;
    if (!selectedElementId) return alert("Select an element row first.");
    const idx = job.elements.findIndex(e => e.id === selectedElementId);
    if (idx < 0) return;
    const j = idx + dir;
    if (j < 0 || j >= job.elements.length) return;
    [job.elements[idx], job.elements[j]] = [job.elements[j], job.elements[idx]];
    saveState(); renderAll();
  }

  // ----- cycles -----
  function clearJobCycles() {
    const job = getActiveJob(); if (!job) return;
    if (!confirm(`Clear all cycles for "${job.name}"?`)) return;
    job.cycles = [];
    selectedCycleId = null;
    selectedCycleIdsForLine = new Set();
    openInlineCycleIds = new Set();
    saveState(); renderAll();
  }
  function deleteCycleById(cycleId) {
    const job = getActiveJob(); if (!job) return;
    const idx = job.cycles.findIndex(c => c.id === cycleId);
    if (idx < 0) return;
    if (!confirm("Delete this cycle?")) return;
    job.cycles.splice(idx, 1);
    selectedCycleIdsForLine.delete(cycleId);
    if (selectedCycleId === cycleId) selectedCycleId = null;
    openInlineCycleIds.delete(cycleId);
    saveState(); renderAll();
  }
  function setCycleTag(cycleId, tag) {
    const job = getActiveJob(); if (!job) return;
    const c = job.cycles.find(x => x.id === cycleId);
    if (!c) return;
    c.tag = tag;
    saveState(); renderAll();
  }
  function applyInlineCycleDetailEdit(inputEl) {
    const job = getActiveJob();
    if (!job) return;
    const cycleId = String(inputEl?.dataset?.cycleId || "");
    const elementId = String(inputEl?.dataset?.elementId || "");
    const kind = String(inputEl?.dataset?.cycleEdit || "");
    if (!cycleId || !elementId || !kind) return;
    const cycle = (job.cycles || []).find((c) => c.id === cycleId);
    if (!cycle) return;

    const rawSec = Number(inputEl.value);
    if (!Number.isFinite(rawSec) || rawSec < 0) {
      renderAll();
      return;
    }
    const valSec = quantizeSec(rawSec);
    let changed = false;

    if (kind === "start") {
      changed = setCycleElementOffsetMs(job, cycleId, elementId, valSec * 1000);
    } else if (kind === "dur") {
      changed = setCycleElementDurationMs(job, cycleId, elementId, valSec * 1000);
    } else if (kind === "end") {
      const schedule = resolveCycleSchedule(job, cycle);
      const seg = schedule.segments.find((s) => s.elementId === elementId);
      const startSec = seg ? quantizeSec(seg.startSec) : 0;
      const durSec = Math.max(0, quantizeSec(valSec - startSec));
      changed = setCycleElementDurationMs(job, cycleId, elementId, durSec * 1000);
    }

    if (!changed) {
      renderAll();
      return;
    }
    selectedCycleId = cycleId;
    state.meta.updatedAt = wallIso();
    saveState();
    renderAll();
  }
  function setCycleNoteById(cycleId, note) {
    const job = getActiveJob(); if (!job) return;
    const c = job.cycles.find(x => x.id === cycleId);
    if (!c) return;
    c.note = note;
    saveState();
  }

  // expand/collapse helpers for inline detail rows
  function expandAllVisibleInline() {
    const job = getActiveJob(); if (!job) return;
    const tagSet = selectedTagsSet();
    const filtered = job.cycles.filter(c => tagSet.has(c.tag || "Normal"));
    for (const c of filtered) openInlineCycleIds.add(c.id);
    renderAll();
  }
  function collapseAllInline() {
    openInlineCycleIds = new Set();
    renderAll();
  }
  function toggleAllVisibleInline() {
    const job = getActiveJob(); if (!job) return;
    const tagSet = selectedTagsSet();
    const filtered = job.cycles.filter(c => tagSet.has(c.tag || "Normal"));
    const anyOpen = filtered.some(c => openInlineCycleIds.has(c.id));
    if (anyOpen) collapseAllInline(); else expandAllVisibleInline();
  }
  function selectAllVisibleCycles() {
    const job = getActiveJob(); if (!job) return;
    const tagSet = selectedTagsSet();
    const filtered = job.cycles.filter(c => tagSet.has(c.tag || "Normal"));
    for (const c of filtered) selectedCycleIdsForLine.add(c.id);
    boundLineSelection(job, 6);
    renderAll();
  }
  function selectAllVisibleCyclesNoCap() {
    const job = getActiveJob(); if (!job) return;
    const tagSet = selectedTagsSet();
    const filtered = job.cycles.filter(c => tagSet.has(c.tag || "Normal"));
    for (const c of filtered) selectedCycleIdsForLine.add(c.id);
    // No cap — user explicitly asked for all
    renderAll();
  }
  function invertVisibleCyclesSelection() {
    const job = getActiveJob(); if (!job) return;
    const tagSet = selectedTagsSet();
    const filtered = job.cycles.filter(c => tagSet.has(c.tag || "Normal"));
    for (const c of filtered) {
      if (selectedCycleIdsForLine.has(c.id)) selectedCycleIdsForLine.delete(c.id);
      else selectedCycleIdsForLine.add(c.id);
    }
    boundLineSelection(job, 6);
    renderAll();
  }
  function toggleLineSelection(cycleId, checked) {
    if (checked) selectedCycleIdsForLine.add(cycleId);
    else selectedCycleIdsForLine.delete(cycleId);
    const job = getActiveJob();
    if (job) boundLineSelection(job, 6);
    renderAll();
  }
  function boundLineSelection(job, maxLines) {
    if (selectedCycleIdsForLine.size <= maxLines) return;
    const recency = job.cycles.slice().reverse().map(c => c.id);
    const kept = new Set();
    for (const id of recency) {
      if (selectedCycleIdsForLine.has(id)) kept.add(id);
      if (kept.size >= maxLines) break;
    }
    selectedCycleIdsForLine = kept;
  }
  function selectLastN(n) {
    const job = getActiveJob(); if (!job) return;
    selectedCycleIdsForLine = new Set(job.cycles.slice(-n).map(c => c.id));
    if (job.cycles.length > 0) selectedCycleId = job.cycles[job.cycles.length - 1].id;
    renderAll();
  }
  function clearLineSelection() {
    selectedCycleIdsForLine = new Set();
    renderAll();
  }

  // ----- export/import -----
  function exportJson() {
    downloadText(`chrono_backup_${new Date().toISOString().slice(0,10)}.json`, JSON.stringify(state, null, 2), "application/json");
  }
  function importJson(file) {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const parsed = JSON.parse(String(reader.result || ""));
        applyImportedState(parsed, "Import file");
      } catch(e) { alert("Import failed: " + e.message); }
    };
    reader.readAsText(file);
  }

  function applyImportedState(parsed, sourceLabel = "Import") {
    if (!parsed || !Array.isArray(parsed.stations) || !Array.isArray(parsed.jobs)) {
      alert("Invalid backup format.");
      return false;
    }
    state = parsed;
    ensureActionTypes(state);
    invalidateActionTypeCache();
    ensureUiState(state);
    for (const j of state.jobs) {
      if (!Array.isArray(j.cycles)) j.cycles = [];
      for (const c of j.cycles) {
        if (!c.tag) c.tag = "Normal";
        if (c.note == null) c.note = "";
      }
    }
    if (!state.activeJobId && state.jobs[0]) state.activeJobId = state.jobs[0].id;
    selectedElementId = null;
    selectedCycleId = null;
    selectedCycleIdsForLine = new Set();
    saveState();
    stopCycle();
    renderAll();
    flashSavePill(`✓ ${sourceLabel}`);
    return true;
  }

  async function loadDemo(url, label) {
    const fileName = String(url).split("/").pop() || url;
    const baseHref = window.location.href.replace(/[^/]*$/, "");
    const candidates = [
      url,
      `./${fileName}`,
      `/chrono/${fileName}`,
      `${baseHref}${fileName}`,
    ];

    const tried = [];
    for (const candidate of candidates) {
      try {
        const res = await fetch(candidate, { cache: "no-store" });
        if (!res.ok) {
          tried.push(`${candidate} -> HTTP ${res.status}`);
          continue;
        }
        const parsed = await res.json();
        applyImportedState(parsed, label);
        return;
      } catch (e) {
        tried.push(`${candidate} -> ${e.message}`);
      }
    }

    if (window.location.protocol === "file:") {
      alert(
        `Demo load failed (${label}): browser blocks fetch on file:// pages.\n\n` +
        `Open from a local server, e.g.:\n` +
        `http://localhost:5173/chrono/chrono.html\n\n` +
        `Or use "Import JSON" and pick a demo file manually.`
      );
      return;
    }

    alert(`Demo load failed (${label}).\n\n${tried.join("\n")}`);
  }

  function clearLocalState() {
    if (!confirm("Clear local chrono data and reset to default?")) return;
    localStorage.removeItem(STORAGE_KEY);
    state = defaultState();
    selectedElementId = null;
    selectedCycleId = null;
    selectedCycleIdsForLine = new Set();
    saveState();
    stopCycle();
    renderAll();
    flashSavePill("✓ Cleared");
  }
  function exportCsv() {
    const job = getActiveJob();
    if (!job) return alert("Select a job first.");
    const st = getStationById(job.stationId);

    const rows = [];
    rows.push(toCsvRow([
      "stationCode","stationName","jobName","allowancePct","ratingPct",
      "cycleId","cycleAtIso","cycleTag","cycleTotalMs",
      "lapIndex","elementName","elementType","lapMs"
    ]));

    for (const c of job.cycles) {
      c.laps.forEach((lap, i) => {
        rows.push(toCsvRow([
          st?.code || "", st?.name || "", job.name, job.allowancePct, job.ratingPct,
          c.id, c.atIso, c.tag || "Normal", c.totalMs,
          i+1, lap.name, lap.type, lap.ms
        ]));
      });
    }
    const safe = (st?.code || "ST") + "_" + job.name.replace(/[^\w\-]+/g, "_");
    downloadText(`${safe}.csv`, rows.join("\n"), "text/csv");
  }

  function getFilteredCyclesForJob(job) {
    const tagSet = selectedTagsSet();
    return (job?.cycles || []).filter((c) => tagSet.has(c.tag || "Normal"));
  }

  function exportKpiActionsCsv() {
    const job = getActiveJob();
    if (!job) return alert("Select a job first.");
    const st = getStationById(job.stationId);
    const filtered = getFilteredCyclesForJob(job);
    const stats = computeCycleStats(job, filtered);
    if (!stats) return alert("No action data.");
    const rowsStats = computeActionStats(job, filtered, stats.avgMs);
    if (!rowsStats.length) return alert("No action data.");
    const unit = timeUnit();
    const res = timeResolutionSec();
    const rows = [];
    rows.push(toCsvRow([
      "stationCode","stationName","jobName","filteredCycles","timeUnit","timeResolutionSec",
      "actionId","actionName","actionType","avgMs","minMs","maxMs","sharePct","avgDisplay","minDisplay","maxDisplay"
    ]));
    for (const r of rowsStats) {
      rows.push(toCsvRow([
        st?.code || "", st?.name || "", job.name, filtered.length, unit, res,
        r.id, r.name, getActionType(r.type).id, quantizeMs(r.avgMs), quantizeMs(r.minMs), quantizeMs(r.maxMs),
        Number(r.sharePct || 0).toFixed(1),
        fmtQtyMs(r.avgMs), fmtQtyMs(r.minMs), fmtQtyMs(r.maxMs)
      ]));
    }
    const safe = (st?.code || "ST") + "_" + job.name.replace(/[^\w\-]+/g, "_");
    downloadText(`${safe}_actions.csv`, rows.join("\n"), "text/csv");
  }

  function buildKpiReportHtml(job) {
    const st = getStationById(job.stationId);
    const filtered = getFilteredCyclesForJob(job);
    const stats = computeCycleStats(job, filtered);
    const rowsStats = stats ? computeActionStats(job, filtered, stats.avgMs) : [];
    const now = new Date().toLocaleString();
    const head = `
      <h2 style="margin:0 0 8px 0;">Chrono KPI Report</h2>
      <div style="color:#444;margin-bottom:12px;">Generated: ${esc(now)}</div>
      <div style="margin-bottom:10px;"><strong>Station:</strong> ${esc(st?.code || "")} - ${esc(st?.name || "")}</div>
      <div style="margin-bottom:10px;"><strong>Job:</strong> ${esc(job.name || "")}</div>
      <div style="margin-bottom:10px;"><strong>Cycles (filtered):</strong> ${filtered.length}</div>
      <div style="margin-bottom:16px;"><strong>Time:</strong> unit=${esc(timeUnit())}, resolution=${esc(String(timeResolutionSec()))}s</div>
    `;
    const kpi = stats ? `
      <table style="width:100%;border-collapse:collapse;margin-bottom:14px;">
        <tr><th style="text-align:left;border-bottom:1px solid #ddd;padding:6px;">Std</th><td style="border-bottom:1px solid #ddd;padding:6px;">${esc(fmtQtyMs(stats.stdMs))}</td></tr>
        <tr><th style="text-align:left;border-bottom:1px solid #ddd;padding:6px;">Avg</th><td style="border-bottom:1px solid #ddd;padding:6px;">${esc(fmtQtyMs(stats.avgMs))}</td></tr>
        <tr><th style="text-align:left;border-bottom:1px solid #ddd;padding:6px;">Median</th><td style="border-bottom:1px solid #ddd;padding:6px;">${esc(fmtQtyMs(stats.medianMs))}</td></tr>
        <tr><th style="text-align:left;border-bottom:1px solid #ddd;padding:6px;">P90</th><td style="border-bottom:1px solid #ddd;padding:6px;">${esc(fmtQtyMs(stats.p90Ms))}</td></tr>
        <tr><th style="text-align:left;border-bottom:1px solid #ddd;padding:6px;">Best/Worst</th><td style="border-bottom:1px solid #ddd;padding:6px;">${esc(fmtQtyMs(stats.bestMs))} / ${esc(fmtQtyMs(stats.worstMs))}</td></tr>
      </table>
    ` : `<div style="margin-bottom:12px;">No KPI data.</div>`;
    const bodyRows = rowsStats.map((r) => `
      <tr>
        <td style="border-bottom:1px solid #eee;padding:6px;">${esc(r.name)}</td>
        <td style="border-bottom:1px solid #eee;padding:6px;">${esc(getActionType(r.type).id)}</td>
        <td style="border-bottom:1px solid #eee;padding:6px;text-align:right;">${esc(fmtQtyMs(r.avgMs))}</td>
        <td style="border-bottom:1px solid #eee;padding:6px;text-align:right;">${esc(fmtQtyMs(r.minMs))}</td>
        <td style="border-bottom:1px solid #eee;padding:6px;text-align:right;">${esc(fmtQtyMs(r.maxMs))}</td>
        <td style="border-bottom:1px solid #eee;padding:6px;text-align:right;">${Number(r.sharePct || 0).toFixed(1)}%</td>
      </tr>
    `).join("");
    const table = `
      <h3 style="margin:12px 0 6px 0;">Action averages</h3>
      <table style="width:100%;border-collapse:collapse;">
        <thead>
          <tr>
            <th style="text-align:left;border-bottom:2px solid #ddd;padding:6px;">Action</th>
            <th style="text-align:left;border-bottom:2px solid #ddd;padding:6px;">Type</th>
            <th style="text-align:right;border-bottom:2px solid #ddd;padding:6px;">Avg</th>
            <th style="text-align:right;border-bottom:2px solid #ddd;padding:6px;">Min</th>
            <th style="text-align:right;border-bottom:2px solid #ddd;padding:6px;">Max</th>
            <th style="text-align:right;border-bottom:2px solid #ddd;padding:6px;">Share</th>
          </tr>
        </thead>
        <tbody>${bodyRows || `<tr><td colspan="6" style="padding:8px;color:#666;">No action data.</td></tr>`}</tbody>
      </table>
    `;
    return `
      <!doctype html><html><head><meta charset="utf-8"/><title>Chrono KPI Report</title></head>
      <body style="font-family:Arial,Helvetica,sans-serif; color:#111; padding:20px;">
        ${head}
        ${kpi}
        ${table}
      </body></html>
    `;
  }

  function openPrintReport() {
    const job = getActiveJob();
    if (!job) return alert("Select a job first.");
    const html = buildKpiReportHtml(job);
    const w = window.open("", "_blank");
    if (!w) return alert("Popup blocked.");
    w.document.open();
    w.document.write(html);
    w.document.close();
    setTimeout(() => {
      try { w.focus(); w.print(); } catch {}
    }, 120);
  }

  // ----- Timeline (stacked horizontal bars) -----
  function getLaneIndexMap() {
    const laneToOrder = new Map();
    for (const at of (state.actionTypes || [])) {
      const lane = String(at.lane || "lane");
      const order = Number(at.laneOrder ?? 0);
      const cur = laneToOrder.get(lane);
      if (cur == null || order < cur) laneToOrder.set(lane, order);
    }
    const lanes = [...laneToOrder.entries()].sort((a, b) => a[1] - b[1]).map(([lane]) => lane);
    const map = new Map();
    lanes.forEach((lane, idx) => map.set(lane, idx));
    return map;
  }
  function laneY(rowY, rowH, laneIdx, hPx, laneStep = 8) {
    const y0 = rowY + rowH - hPx - laneIdx * laneStep;
    return Math.max(rowY, Math.min(rowY + rowH - hPx, y0));
  }
  function getActionLayers(typeId) {
    const at = getActionType(typeId);
    const layers = [];
    if (at.underlayTypeId) {
      const under = getActionType(at.underlayTypeId);
      layers.push({
        color: under.color, lane: under.lane, heightPx: under.heightPx, z: Number(under.z ?? 0), opacity: Number(under.opacity ?? 1)
      });
    }
    layers.push({
      color: at.color, lane: at.lane, heightPx: at.heightPx, z: Number(at.z ?? 10), opacity: Number(at.opacity ?? 1)
    });
    return layers.sort((a, b) => a.z - b.z);
  }

  function actionRoleFlags(typeId, laneId = "", atOverride = null) {
    const at = atOverride || getActionType(typeId);
    const tid = String(typeId || at?.id || "").toUpperCase();
    const txt = `${tid} ${String(at?.name || "").toUpperCase()} ${String(laneId || at?.lane || "").toUpperCase()}`;
    const machine = /\b(MACHINE|TECH|TECCH|ROBOT|CNC|AUTO)\b/.test(txt);
    const human = /\b(HUMAN|OPERATOR|MANUAL|PERSON)\b/.test(txt);
    return { machine, human, machineOnly: machine && !human };
  }

  const machinePatternByCtx = new WeakMap();
  function getMachinePattern(ctx) {
    const cached = machinePatternByCtx.get(ctx);
    if (cached) return cached;
    const pc = document.createElement("canvas");
    pc.width = 12;
    pc.height = 12;
    const pctx = pc.getContext("2d");
    pctx.clearRect(0, 0, 12, 12);
    pctx.fillStyle = "rgba(126,136,150,0.35)";
    pctx.fillRect(0, 0, 12, 12);
    pctx.strokeStyle = "rgba(220,228,238,0.70)";
    pctx.lineWidth = 2;
    pctx.beginPath();
    pctx.moveTo(-2, 10);
    pctx.lineTo(10, -2);
    pctx.moveTo(2, 14);
    pctx.lineTo(14, 2);
    pctx.stroke();
    const pattern = ctx.createPattern(pc, "repeat");
    machinePatternByCtx.set(ctx, pattern);
    return pattern;
  }

  function drawMachineBoxRect(ctx, x, y, w, h, opacity = 1, bordered = true) {
    if (w <= 0 || h <= 0) return;
    ctx.save();
    ctx.globalAlpha = Math.max(0.05, Math.min(1, Number(opacity || 1)));
    ctx.fillStyle = "rgba(100,112,128,0.28)";
    ctx.fillRect(x, y, w, h);
    const hatch = getMachinePattern(ctx);
    if (hatch) {
      ctx.fillStyle = hatch;
      ctx.fillRect(x, y, w, h);
    }
    if (bordered) {
      ctx.strokeStyle = "rgba(51,198,255,0.95)";
      ctx.lineWidth = 1.6;
      ctx.strokeRect(x + 0.5, y + 0.5, Math.max(0, w - 1), Math.max(0, h - 1));
    }
    ctx.restore();
  }

  function resolveHeightPx(typeId, rawH, rowH) {
    const raw = Math.max(2, Number(rawH || 6));
    return Math.max(2, Math.min(Math.max(3, rowH - 1), raw));
  }

  function drawEmpty(ctx,w,h,msg){
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle="rgba(255,255,255,0.60)";
    ctx.font="14px system-ui, sans-serif";
    ctx.textAlign="center";
    ctx.fillText(msg, w/2, h/2);
    ctx.textAlign="left";
  }

  function setCycleElementDurationMs(job, cycleId, elementId, nextMs) {
    const cycle = (job?.cycles || []).find((c) => c.id === cycleId);
    if (!cycle) return false;
    const targetMs = quantizeMs(Math.max(0, Number(nextMs || 0)));
    const laps = (cycle.laps || []).filter((lap) => lap.elementId === elementId);
    if (!laps.length) {
      const el = (job.elements || []).find((e) => e.id === elementId);
      if (!el) return false;
      cycle.laps.push({ elementId: el.id, name: el.name, type: el.type, ms: quantizeMs(targetMs) });
    } else {
      const sumMs = laps.reduce((a, l) => a + quantizeMs(Math.max(0, Number(l.ms || 0))), 0);
      if (sumMs <= 0) {
        const each = quantizeMs(targetMs / Math.max(1, laps.length));
        for (const lap of laps) lap.ms = each;
      } else {
        const k = targetMs / sumMs;
        for (const lap of laps) lap.ms = quantizeMs(Math.max(0, Number(lap.ms || 0) * k));
      }
    }
    cycle.totalMs = quantizeMs((cycle.laps || []).reduce((a, l) => a + quantizeMs(Math.max(0, Number(l.ms || 0))), 0));
    return true;
  }

  function setCycleElementOffsetMs(job, cycleId, elementId, startMs) {
    const cycle = (job?.cycles || []).find((c) => c.id === cycleId);
    if (!cycle) return false;
    if (!cycle.timelineOffsetsMs || typeof cycle.timelineOffsetsMs !== "object") cycle.timelineOffsetsMs = {};
    const v = quantizeMs(Math.max(0, Number(startMs || 0)));
    cycle.timelineOffsetsMs[elementId] = v;
    return true;
  }

  function getActionResourceKeys(typeId, laneId) {
    const at = getActionType(typeId);
    if (at && at.stackFlow === false) return [];
    const lane = String(laneId || at?.lane || "lane");
    const mode = String(at?.resourceMode || "AUTO").toUpperCase();
    const keys = [];
    if (mode === "FREE") return keys;
    if (mode === "HUMAN") return ["res:human"];
    if (mode === "MACHINE") return ["res:machine"];
    if (mode === "BOTH") return ["res:machine", "res:human"];
    if (mode === "LANE") return [`lane:${lane}`];
    const roles = actionRoleFlags(typeId, laneId, at);
    if (roles.machine) keys.push("res:machine");
    if (roles.human) keys.push("res:human");
    if (!keys.length) keys.push(`lane:${lane}`);
    return keys;
  }

  function resolveCycleSchedule(job, cycle) {
    const sums = new Map();
    for (const lap of (cycle?.laps || [])) {
      const eid = String(lap.elementId || "");
      sums.set(eid, (sums.get(eid) || 0) + quantizeMs(Math.max(0, Number(lap.ms || 0))));
    }
    const offsets = cycle?.timelineOffsetsMs && typeof cycle.timelineOffsetsMs === "object"
      ? cycle.timelineOffsetsMs
      : {};
    const resourceEnd = new Map();
    const segments = [];

    for (const el of (job?.elements || [])) {
      const ms = quantizeMs(Math.max(0, Number(sums.get(el.id) || 0)));
      if (ms <= 0) continue;
      const at = getActionType(el.type);
      const typeId = String(el.type || "").toUpperCase();
      const resources = getActionResourceKeys(typeId, at.lane);
      const blockAt = resources.reduce((mx, rk) => Math.max(mx, Number(resourceEnd.get(rk) || 0)), 0);
      const reqStart = quantizeSec(Math.max(0, Number(offsets[el.id] || 0) / 1000));
      const startSec = resources.length ? Math.max(blockAt, reqStart) : reqStart;
      const durSec = quantizeSec(ms / 1000);
      const endSec = startSec + durSec;
      for (const rk of resources) resourceEnd.set(rk, Math.max(Number(resourceEnd.get(rk) || 0), endSec));
      segments.push({ elementId: el.id, elementRef: el, typeId, at, startSec, endSec, durSec });
    }
    const rowEndSec = segments.reduce((mx, s) => Math.max(mx, s.endSec), 0);
    return { segments, rowEndSec };
  }

  function toCanvasPoint(canvas, evt) {
    const rect = canvas.getBoundingClientRect();
    if (!rect.width || !rect.height) return null;
    const sx = canvas.width / rect.width;
    const sy = canvas.height / rect.height;
    return {
      x: (Number(evt.clientX || 0) - rect.left) * sx,
      y: (Number(evt.clientY || 0) - rect.top) * sy,
    };
  }

  function findTimelineHit(geom, x, y) {
    const hits = geom?.hits || [];
    for (let i = hits.length - 1; i >= 0; i--) {
      const h = hits[i];
      if (x >= h.x0 && x <= h.x1 && y >= h.y && y <= (h.y + h.h)) return h;
    }
    return null;
  }

  function timelineSecDelta(geom, dxPx) {
    if (!geom?.cw || !geom?.xMaxSec) return 0;
    return (dxPx / geom.cw) * geom.xMaxSec;
  }

  function drawTimeline(canvas, job, baseCycles, selectedCycles, avgByElSec, outModel, showAvg, showOutliers) {
    const ctx = canvas.getContext("2d");
    const w=canvas.width, h=canvas.height;
    ctx.clearRect(0,0,w,h);
    timelineEditState.geom = null;

    if (!job || job.elements.length === 0) return drawEmpty(ctx,w,h,"No elements");
    if (!baseCycles.length && !selectedCycles.length) return drawEmpty(ctx,w,h,"No cycles (check tag filter)");

    // layout
    const padL=120, padR=16, padT=16, padB=48;
    const cw=w-padL-padR, ch=h-padT-padB;

    // which cycles to draw as rows:
    // In ALL mode => rows = baseCycles (can be many)
    // In SELECTED => rows = selectedCycles (max 6)
    const rows = (graphMode === "ALL") ? baseCycles : selectedCycles;
    if (!rows.length) return drawEmpty(ctx,w,h,"Select cycles (or switch to All)");

    const maxRowsToDraw = 80; // keep performance ok in-browser
    const drawRows = (graphMode === "ALL" && rows.length > maxRowsToDraw)
      ? rows.slice(-maxRowsToDraw)
      : rows;

    // compute row schedules + x range (stacked view may extend beyond cycle.totalMs)
    const rowSchedules = new Map();
    let xMaxSec = 1;
    for (const c of drawRows) {
      const sch = resolveCycleSchedule(job, c);
      rowSchedules.set(c.id, sch);
      xMaxSec = Math.max(xMaxSec, Number(sch.rowEndSec || 0));
    }
    xMaxSec *= 1.10;

    const laneMap = getLaneIndexMap();
    const laneCount = Math.max(1, Number(laneMap?.size || 1));
    const sameBase = !!state.ui?.timelineSameBase;
    const usedTypeIds = [...new Set((job.elements || []).map((el) => String(el.type || "").toUpperCase()).filter(Boolean))];
    const maxCfgHeight = Math.max(6, ...usedTypeIds.map((tid) => Math.max(2, Number(getActionType(tid).heightPx || 6))));
    const defaultLaneStep = (sameBase || laneCount <= 1) ? 0 : Math.max(6, Math.round(maxCfgHeight * 0.65));
    const minRowByConfig = maxCfgHeight + Math.max(0, laneCount - 1) * defaultLaneStep + 6;
    const rowH = Math.max(minRowByConfig, Math.min(96, ch / Math.max(1, drawRows.length)));
    const gap = Math.max(6, Math.min(14, rowH * 0.24));
    const laneStep = (sameBase || laneCount <= 1) ? 0 : Math.max(6, Math.round((rowH - maxCfgHeight - 4) / Math.max(1, laneCount - 1)));

    const xOf = (sec) => padL + (sec/xMaxSec)*cw;
    const hits = [];

    // axes
    ctx.strokeStyle="rgba(255,255,255,0.10)";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(padL,padT);
    ctx.lineTo(padL,padT+ch);
    ctx.lineTo(padL+cw,padT+ch);
    ctx.stroke();

    // x ticks (time unit)
    ctx.fillStyle="rgba(255,255,255,0.55)";
    ctx.font="12px ui-monospace, Menlo, Consolas, monospace";
    const ticks=5;
    for (let i=0;i<=ticks;i++){
      const sec = xMaxSec*i/ticks;
      const x = xOf(sec);
      ctx.strokeStyle="rgba(255,255,255,0.06)";
      ctx.beginPath(); ctx.moveTo(x,padT); ctx.lineTo(x,padT+ch); ctx.stroke();
      ctx.fillText(fmtAxisValue(sec), x-14, padT+ch+22);
    }
    ctx.fillStyle="rgba(255,255,255,0.55)";
    ctx.font="12px system-ui, sans-serif";
    ctx.fillText(`${timeUnit() === "min" ? t("uiTimeUnitMin", "Minutes") : t("uiTimeUnitSec", "Seconds")} ->`, padL, padT+ch+42);

    // Avg markers per element: draw small vertical markers at cumulative avg boundaries
    // We build cumulative avg per element slot:
    const avgCum = [];
    if (showAvg && avgByElSec) {
      let cum = 0;
      for (let i=0;i<job.elements.length;i++){
        const el = job.elements[i];
        const v = avgByElSec.get(el.id);
        if (v != null) cum += v;
        avgCum.push(cum);
      }
      ctx.setLineDash([6,6]);
      ctx.strokeStyle="rgba(255,255,255,0.65)";
      ctx.lineWidth=1.4;
      for (const s of avgCum) {
        const x = xOf(s);
        ctx.beginPath();
        ctx.moveTo(x, padT);
        ctx.lineTo(x, padT+ch);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }

    // Row labels + stacked bars
    ctx.textAlign="right";
    for (let r=0;r<drawRows.length;r++){
      const c = drawRows[r];
      const y = padT + r*(rowH+gap);
      if (y + rowH > padT+ch) break;

      // row label
      ctx.fillStyle="rgba(255,255,255,0.60)";
      ctx.font="12px ui-monospace, Menlo, Consolas, monospace";
      ctx.fillText(new Date(c.atIso).toLocaleTimeString(), padL-8, y+rowH-2);

      const schedule = rowSchedules.get(c.id) || { segments: [], rowEndSec: 0 };

      // Sort segments by z ascending so high-z types draw last (on top)
      const sortedSegs = [...schedule.segments].sort((a, b) => {
        const za = Number((a.at || getActionType(a.typeId)).z ?? 10);
        const zb = Number((b.at || getActionType(b.typeId)).z ?? 10);
        return za - zb;
      });
      // Track hit areas for ALL segs.
      const segHitInfo = new Map();
      for (let i=0;i<sortedSegs.length;i++){
        const seg = sortedSegs[i];
        const segSec = Number(seg.durSec || 0);
        const x0 = xOf(Number(seg.startSec || 0));
        const x1 = xOf(Number(seg.endSec || 0));
        const width = Math.max(0, x1 - x0);
        const elDef = seg.elementRef || job.elements.find((e) => e.id === seg.elementId);
        if (!elDef) continue;
        const typeId = String(seg.typeId || elDef.type || "").toUpperCase();
        const at = seg.at || getActionType(typeId);
        const laneIdx = sameBase ? 0 : (laneMap.get(at.lane) ?? 0);
        const hPx = resolveHeightPx(typeId, at.heightPx, rowH);
        const y0 = laneY(y, rowH, laneIdx, hPx, laneStep);
        let primaryY = y0, primaryH = hPx;

        // Draw all layers (underlay first via z-sort in getActionLayers)
        const layers = getActionLayers(typeId);
        for (let li = 0; li < layers.length; li++) {
          const layer = layers[li];
          const lIdx = sameBase ? 0 : (laneMap.get(layer.lane) ?? laneIdx);
          const lH = resolveHeightPx(typeId, layer.heightPx, rowH);
          const ly = laneY(y, rowH, lIdx, lH, laneStep);
          if (li === layers.length - 1) { primaryY = ly; primaryH = lH; }
          const roles = actionRoleFlags(typeId, at.lane, at);
          const isPureMachine = roles.machineOnly && layers.length === 1;
          ctx.save();
          ctx.globalAlpha = Math.max(0.05, Math.min(1, Number(layer.opacity ?? 1)));
          if (isPureMachine) {
            ctx.fillStyle = "rgba(100,112,128,0.28)";
            ctx.fillRect(x0, ly, width, lH);
            const hatch = getMachinePattern(ctx);
            if (hatch) { ctx.fillStyle = hatch; ctx.fillRect(x0, ly, width, lH); }
          } else {
            ctx.fillStyle = layer.color || "#4c73ff";
            ctx.fillRect(x0, ly, width, lH);
          }
          ctx.restore();
        }

        // Machine-style cyan border for any type containing MACHINE
        if (actionRoleFlags(typeId, at.lane, at).machine) {
          ctx.save();
          ctx.globalAlpha = 0.90;
          ctx.strokeStyle = "rgba(51,198,255,0.92)";
          ctx.lineWidth = 1.5;
          ctx.strokeRect(x0 + 0.5, y0 + 0.5, Math.max(0, width - 1), Math.max(0, hPx - 1));
          ctx.restore();
        }

        // Start/end ticks for clearer visual boundaries.
        if (width > 0.6) {
          const tickH = Math.max(5, Math.min(16, hPx - 2));
          const yTick = y0 + Math.max(1, (hPx - tickH) / 2);
          ctx.save();
          ctx.strokeStyle = "rgba(255,255,255,0.92)";
          ctx.lineWidth = 1.4;
          ctx.beginPath();
          ctx.moveTo(x0 + 0.5, yTick);
          ctx.lineTo(x0 + 0.5, yTick + tickH);
          ctx.moveTo(x1 - 0.5, yTick);
          ctx.lineTo(x1 - 0.5, yTick + tickH);
          ctx.stroke();
          ctx.restore();
        }

        segHitInfo.set(seg.elementId + "_" + i, { primaryY, primaryH, x0, x1, segSec, elDef });

        if (segSec > 0) {
          hits.push({
            cycleId: c.id,
            elementId: elDef.id,
            x0: Math.min(x0, x1),
            x1: Math.max(x0, x1),
            y,
            h: rowH,
            sec: segSec,
            startSec: Number(seg.startSec || 0),
            endSec: Number(seg.endSec || 0),
          });
        }
      }

      // Now draw outlier outlines on top (after all z-sorted bars)
      for (const [, info] of segHitInfo) {
        const { primaryY, primaryH, x0, x1, segSec, elDef } = info;
        const width = Math.max(0, x1 - x0);
        if (showOutliers && outModel) {
          const m = outModel.get(elDef.id);
          if (m) {
            let isOut = false;
            if (m.mode === "MULT_1_5") isOut = segSec > m.hi;
            else isOut = (m.lo != null && segSec < m.lo) || (m.hi != null && segSec > m.hi);
            if (isOut) {
              ctx.strokeStyle = "rgba(255,76,106,0.95)";
              ctx.lineWidth = 2.0;
              ctx.strokeRect(x0+1, primaryY+1, Math.max(0,width-2), Math.max(0,primaryH-2));
            }
          }
        }
      }

      // outline selected cycles in ALL mode (if checked)
      if (graphMode === "ALL" && selectedCycleIdsForLine.has(c.id)) {
        ctx.strokeStyle = accentRgba(0.85);
        ctx.lineWidth=2.0;
        ctx.strokeRect(padL, y, Math.max(0, xOf(Number(schedule.rowEndSec || 0))-padL), rowH);
      }
    }
    ctx.textAlign="left";
    timelineEditState.geom = { padL, padR, padT, padB, cw, ch, xMaxSec, hits };
  }

  function renderLegend(job) {
    const el = $("chartLegend");
    el.innerHTML = "";
    if (!job || !job.elements.length) return;

    const usedTypeIds = [];
    const seenType = new Set();
    for (let i=0;i<job.elements.length;i++){
      const tid = String(job.elements[i].type || "").toUpperCase();
      if (seenType.has(tid)) continue;
      seenType.add(tid);
      usedTypeIds.push(tid);
    }
    for (const tid of usedTypeIds){
      const at = getActionType(tid);
      const item = document.createElement("div");
      item.className="legendItem";
      item.innerHTML = `<span class="swatch" style="background:${esc(at.color)};"></span> ${esc(at.id)} - ${esc(at.name)} (lane ${esc(at.lane)}, h ${Number(at.heightPx).toFixed(0)}px)`;
      el.appendChild(item);
      if (el.childNodes.length >= 12) break;
    }
    if (usedTypeIds.length > 12) {
      const more = document.createElement("div");
      more.className="legendItem";
      more.textContent = `... +${usedTypeIds.length - 12} more`;
      el.appendChild(more);
    }

    if ($("showAvgLineChk").checked) {
      const item = document.createElement("div");
      item.className="legendItem";
      item.innerHTML = `<span class="swatch" style="background:rgba(255,255,255,0.65);"></span> Avg boundaries`;
      el.appendChild(item);
    }
    if ($("showOutliersChk").checked) {
      const item = document.createElement("div");
      item.className="legendItem";
      item.innerHTML = `<span class="swatch" style="background:rgba(255,76,106,0.95);"></span> Outlier outline`;
      el.appendChild(item);
    }
  }

  // ----- Rendering -----
  function renderStationJobSidebar() {
    const container = $("stationsList");
    container.innerHTML = "";
    const q = searchText.trim().toLowerCase();

    for (const st of state.stations) {
      const jobs = state.jobs.filter(j => j.stationId === st.id);
      const stationMatch = (st.code + " " + st.name).toLowerCase().includes(q);
      const filteredJobs = q ? jobs.filter(j => (j.name).toLowerCase().includes(q) || stationMatch) : jobs;
      if (q && !stationMatch && filteredJobs.length === 0) continue;

      const block = document.createElement("div");
      block.className = "stationBlock";
      const stationCollapsed = !!state.ui?.collapsedStations?.[st.id];

      const head = document.createElement("div");
      head.className = "stationHeader";
      head.innerHTML = `
        <div style="min-width:0;">
          <div class="stationName">${esc(st.code)} - ${esc(st.name)}</div>
          <div class="stationMeta">${filteredJobs.length} ${t("jobsCount", "job(s)")}</div>
        </div>
        <div class="btnbar" style="gap:6px;">
          <button class="iconBtn iconOnly" data-act="newJob" title="${esc(t("newJob", "New Job"))}">+</button>
          <button class="iconBtn iconOnly" data-act="edit" title="${esc(t("edit", "Edit"))}">✎</button>
          <button class="iconBtn iconOnly" data-act="del" title="${esc(t("delete", "Delete"))}">🗑</button>
        </div>
      `;
      head.addEventListener("click", (e) => {
        const act = e.target?.dataset?.act;
        if (act === "newJob") {
          e.stopPropagation();
          const id = uuid();
          state.jobs.unshift({ id, stationId: st.id, name:"New job", allowancePct:12, ratingPct:100, elements:[], cycles:[] });
          state.activeJobId = id;
          selectedElementId=null; selectedCycleId=null; selectedCycleIdsForLine=new Set();
          saveState(); renderAll(); openDrawer();
          $("jobName").focus(); $("jobName").select();
          return;
        }
        if (act === "edit") { e.stopPropagation(); renameStation(st.id); return; }
        if (act === "del") { e.stopPropagation(); deleteStation(st.id); return; }
        ensureUiState(state);
        state.ui.collapsedStations[st.id] = !state.ui.collapsedStations[st.id];
        saveState();
        renderStationJobSidebar();
      });
      block.appendChild(head);

      const list = document.createElement("div");
      list.className = "jobList";
      if (stationCollapsed) list.style.display = "none";

      for (const job of filteredJobs) {
        const active = (job.id === state.activeJobId);
        const { score, level } = jobProgress(job);
        const item = document.createElement("div");
        item.className = "jobItem" + (active ? " active" : "");
        item.innerHTML = `
          <div style="min-width:0; flex:1;">
            <div class="jobName">${esc(job.name)}</div>
            <div class="jobMeta">
              <span class="mono">${t("els", "els")}: ${job.elements.length}</span>
              <span class="mono">${t("cyclesLabel", "cycles")}: ${job.cycles.length}</span>
              <span class="mono">A:${Number(job.allowancePct).toFixed(0)}%</span>
              <span class="mono">R:${Number(job.ratingPct).toFixed(0)}%</span>
            </div>
            <div class="progressWrap">
              <div class="progressBar ${level === "good" ? "good" : (level === "mid" ? "" : "warn")}" style="width:${score}%;"></div>
            </div>
            <div class="tiny">${t("progress", "Progress")}: ${score}%</div>
          </div>
          <div class="btnbar" style="gap:6px;">
            <button class="iconBtn" data-act="cfg">${t("cfg", "Cfg")}</button>
          </div>
        `;
        item.addEventListener("click", (e) => {
          const act = e.target?.dataset?.act;
          if (act === "cfg") { e.stopPropagation(); selectJob(job.id); openDrawer(); return; }
          selectJob(job.id);
        });
        list.appendChild(item);
      }
      block.appendChild(list);
      container.appendChild(block);
    }
  }

  function renderTimelineScopeSelectors() {
    const stationSel = $("timelineStationSel");
    const jobSel = $("timelineJobSel");
    if (!stationSel || !jobSel) return;

    const activeJob = getActiveJob();
    const activeStationId = activeJob?.stationId || state.stations[0]?.id || "";

    stationSel.innerHTML = "";
    for (const st of state.stations) {
      const opt = document.createElement("option");
      opt.value = st.id;
      opt.textContent = `${st.code} - ${st.name}`;
      stationSel.appendChild(opt);
    }
    if (!state.stations.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "— No stations —";
      stationSel.appendChild(opt);
      stationSel.disabled = true;
    } else {
      stationSel.disabled = false;
      stationSel.value = activeStationId;
    }

    const stationId = stationSel.value || activeStationId;
    const jobsAtStation = state.jobs.filter((j) => j.stationId === stationId);
    jobSel.innerHTML = "";
    for (const job of jobsAtStation) {
      const opt = document.createElement("option");
      opt.value = job.id;
      opt.textContent = job.name;
      jobSel.appendChild(opt);
    }
    if (!jobsAtStation.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "— No jobs —";
      jobSel.appendChild(opt);
      jobSel.disabled = true;
    } else {
      jobSel.disabled = false;
      const fallbackJobId = jobsAtStation[0].id;
      const activeInStation = activeJob && jobsAtStation.some((j) => j.id === activeJob.id);
      jobSel.value = activeInStation ? activeJob.id : fallbackJobId;
    }
  }

  function setAllStationsCollapsed(collapsed) {
    ensureUiState(state);
    for (const st of state.stations) {
      state.ui.collapsedStations[st.id] = !!collapsed;
    }
    saveState();
    renderAll();
  }

  function renderJobConfigDrawer() {
    const job = getActiveJob();
    ensureActionTypes(state);
    ensureUiState(state);
    applyDrawerSectionsUi();

    // Job quick-switch selector
    const jss = $("jobSwitchSel");
    if (jss) {
      const prev = jss.value;
      jss.innerHTML = "";
      if (!state.jobs.length) {
        const o = document.createElement("option"); o.value = ""; o.textContent = "— No jobs —"; jss.appendChild(o);
      } else {
        for (const j of state.jobs) {
          const st2 = getStationById(j.stationId);
          const o = document.createElement("option");
          o.value = j.id;
          o.textContent = (st2 ? st2.code + " · " : "") + j.name + ` (${(j.elements||[]).length} el., ${(j.cycles||[]).length} cyc.)`;
          jss.appendChild(o);
        }
        jss.value = state.activeJobId || "";
      }
    }

    const sel = $("jobStationSelect");
    sel.innerHTML = "";
    for (const st of state.stations) {
      const opt = document.createElement("option");
      opt.value = st.id;
      opt.textContent = `${st.code} - ${st.name}`;
      sel.appendChild(opt);
    }

    const typeSel = $("elType");
    typeSel.innerHTML = "";
    for (const at of state.actionTypes) {
      const opt = document.createElement("option");
      opt.value = at.id;
      opt.textContent = `${at.id} - ${at.name}`;
      typeSel.appendChild(opt);
    }
    const underlaySel = $("atUnderlay");
    underlaySel.innerHTML = `<option value="">(none)</option>`;
    for (const at of state.actionTypes) {
      const opt = document.createElement("option");
      opt.value = at.id;
      opt.textContent = `${at.id} - ${at.name}`;
      underlaySel.appendChild(opt);
    }
    // Restore form inputs if we are currently editing a type (renderAll resets the underlay dropdown)
    if (editingActionTypeId) {
      const editing = state.actionTypes.find(x => x.id === editingActionTypeId);
      if (editing) {
        $("atId").value = editing.id;
        $("atName").value = editing.name;
        $("atLane").value = editing.lane;
        $("atColor").value = normalizeHexColor(editing.color);
        $("atHeight").value = String(Math.round(Number(editing.heightPx ?? 6)));
        $("atLaneOrder").value = String(Math.round(Number(editing.laneOrder ?? 0)));
        $("atZ").value = String(Math.round(Number(editing.z ?? 10)));
        $("atOpacity").value = String(Math.round(Math.max(0.05, Math.min(1, Number(editing.opacity ?? 1))) * 100));
        underlaySel.value = editing.underlayTypeId || "";
        const stackChk = $("atStackFlow");
        if (stackChk) stackChk.checked = editing.stackFlow !== false;
        const modeSel = $("atResourceMode");
        if (modeSel) modeSel.value = String(editing.resourceMode || "AUTO");
      } else {
        // Type was deleted or not found, reset edit state
        editingActionTypeId = null;
        const stackChk = $("atStackFlow");
        if (stackChk) stackChk.checked = true;
        const modeSel = $("atResourceMode");
        if (modeSel) modeSel.value = "AUTO";
        updateAddTypeButton();
      }
    }
    setUiScale(state.ui.uiScale);
    syncViewLayoutInputs();
    const sameBaseChk = $("uiTimelineSameBaseChk");
    if (sameBaseChk) sameBaseChk.checked = !!state.ui.timelineSameBase;

    const disabled = !job;
    for (const id of ["jobStationSelect","jobName","allowancePct","ratingPct","dupJobBtn","delJobBtn"]) $(id).disabled = disabled;
    if ($("jobSwitchSel")) $("jobSwitchSel").disabled = state.jobs.length === 0;
    $("newJobBtn").disabled = state.stations.length === 0;

    if (!job) {
      $("jobName").value = "";
      $("allowancePct").value = 12;
      $("ratingPct").value = 100;
      $("stationCodeView").value = "";
      renderElementsTable(null);
      renderActionTypesTable();
      return;
    }

    sel.value = job.stationId;
    $("jobName").value = job.name;
    $("allowancePct").value = job.allowancePct;
    $("ratingPct").value = job.ratingPct;
    $("stationCodeView").value = getStationById(job.stationId)?.code || "";
    if (job.elements.length && !selectedElementId) selectedElementId = job.elements[0].id;
    const selEl = job.elements.find((e) => e.id === selectedElementId);
    typeSel.value = selEl ? String(selEl.type || "").toUpperCase() : (state.actionTypes[0]?.id || "");
    renderElementsTable(job);
    renderActionTypesTable();
  }

  function renderElementsTable(job) {
    const body = $("elementsBody");
    body.innerHTML = "";
    if (!job || job.elements.length === 0) {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="3" class="muted">${esc(t("noElements", "No elements."))}</td>`;
      body.appendChild(tr);
      return;
    }
    job.elements.forEach((el, idx) => {
      const tr = document.createElement("tr");
      tr.style.cursor="pointer";
      tr.style.background = (el.id === selectedElementId) ? accentRgba(0.10) : "transparent";
      tr.innerHTML = `
        <td class="mono">${idx+1}</td>
        <td><strong>${esc(el.name)}</strong></td>
        <td><span class="pill">${esc(getActionType(el.type).name)}</span></td>
      `;
      tr.addEventListener("click", () => {
        selectedElementId = el.id;
        $("elType").value = String(el.type || "").toUpperCase();
        renderElementsTable(job);
      });
      body.appendChild(tr);
    });
  }

  function normalizeHexColor(input) {
    return /^#[0-9a-fA-F]{6}$/.test(String(input || "")) ? String(input) : "#4c73ff";
  }

  function renderActionTypesTable() {
    const body = $("actionTypesBody");
    if (!body) return;
    body.innerHTML = "";
    for (const at of state.actionTypes) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="mono">${esc(at.id)}</td>
        <td>${esc(at.name)}</td>
        <td class="mono">${esc(at.lane)}</td>
        <td class="mono">${Number(at.heightPx).toFixed(0)}</td>
        <td class="mono">${Number(at.z).toFixed(0)}</td>
        <td class="mono">${at.stackFlow === false ? "No" : "Yes"}</td>
        <td class="mono">${esc(String(at.resourceMode || "AUTO"))}</td>
        <td><span style="display:inline-block;width:24px;height:14px;border-radius:4px;border:1px solid rgba(255,255,255,.18);background:${esc(at.color)};"></span></td>
        <td class="right"><button class="danger" data-del-at="${esc(at.id)}" style="padding:6px 10px; border-radius:10px;">Delete</button></td>
      `;
      tr.addEventListener("click", (e) => {
        const delId = e.target?.dataset?.delAt;
        if (delId) {
          e.stopPropagation();
          deleteActionType(delId);
          return;
        }
        // populate inputs for editing
        editingActionTypeId = at.id;
        $("atId").value = at.id;
        $("atName").value = at.name;
        $("atLane").value = at.lane;
        $("atColor").value = normalizeHexColor(at.color);
        $("atHeight").value = String(Math.round(Number(at.heightPx ?? 6)));
        $("atLaneOrder").value = String(Math.round(Number(at.laneOrder ?? 0)));
        $("atZ").value = String(Math.round(Number(at.z ?? 10)));
        $("atOpacity").value = String(Math.round(Math.max(0.05, Math.min(1, Number(at.opacity ?? 1))) * 100));
        $("atUnderlay").value = at.underlayTypeId || "";
        $("atStackFlow").checked = at.stackFlow !== false;
        $("atResourceMode").value = String(at.resourceMode || "AUTO");
        updateAddTypeButton();
      });
      body.appendChild(tr);
    }
  }

  function upsertActionTypeFromInputs() {
    const id = String($("atId").value || "").trim().toUpperCase();
    if (!id) return alert("Type ID required.");
    const next = normalizeActionType({
      id,
      name: String($("atName").value || id).trim() || id,
      lane: String($("atLane").value || id.toLowerCase()).trim() || "lane",
      color: normalizeHexColor($("atColor").value),
      heightPx: $("atHeight").value !== "" ? Number($("atHeight").value) : 6,
      laneOrder: $("atLaneOrder").value !== "" ? Number($("atLaneOrder").value) : 0,
      z: $("atZ").value !== "" ? Number($("atZ").value) : 10,
      opacity: Math.max(0.01, Math.min(1, ($("atOpacity").value !== "" ? Number($("atOpacity").value) : 100) / 100)),
      underlayTypeId: String($("atUnderlay").value || "").trim().toUpperCase(),
      stackFlow: !!$("atStackFlow")?.checked,
      resourceMode: String($("atResourceMode")?.value || "AUTO").toUpperCase(),
    });
    // handle rename if editing existing
    if (editingActionTypeId && editingActionTypeId !== id) {
      const oldId = String(editingActionTypeId).toUpperCase();
      const oldIdx = state.actionTypes.findIndex(x => x.id === oldId);
      if (oldIdx >= 0) state.actionTypes.splice(oldIdx, 1);
      for (const at of (state.actionTypes || [])) {
        if (String(at.underlayTypeId || "").toUpperCase() === oldId) at.underlayTypeId = id;
      }
      for (const job of (state.jobs || [])) {
        for (const el of (job.elements || [])) {
          if (String(el.type || "").toUpperCase() === oldId) el.type = id;
        }
        for (const cyc of (job.cycles || [])) {
          for (const lap of (cyc.laps || [])) {
            if (String(lap.type || "").toUpperCase() === oldId) lap.type = id;
          }
        }
      }
    }
    const idx = state.actionTypes.findIndex((x) => x.id === id);
    if (idx >= 0) state.actionTypes[idx] = next;
    else state.actionTypes.push(next);
    ensureActionTypes(state);
    invalidateActionTypeCache();
    saveState();
    renderAll();
    // keep the inputs populated with saved values so user sees change
    editingActionTypeId = id;
    updateAddTypeButton();
  }

  function deleteActionType(typeId) {
    const id = String(typeId || "").toUpperCase();
    if (!id) return;
    if (!confirm(`Delete action type "${id}"?`)) return;
    if ((state.actionTypes || []).length <= 1) return alert("Need at least one action type.");
    state.actionTypes = state.actionTypes.filter((x) => x.id !== id);
    const fallback = state.actionTypes[0]?.id || "IDLE";
    for (const job of state.jobs) {
      for (const el of (job.elements || [])) {
        if (String(el.type || "").toUpperCase() === id) el.type = fallback;
      }
    }
    ensureActionTypes(state);
    invalidateActionTypeCache();
    saveState();
    renderAll();
  }

  function renderHeaderKpisTimerGraph() {
    const job = getActiveJob();
    renderCaptureSelectors();
    refreshCaptureModeUI();
    const tagSet = selectedTagsSet();

    // header
    if (!job) {
      $("jobHeader").textContent = t("selectJob", "Select a job");
      const hjl = $("hJobLabel"); if (hjl) hjl.textContent = t("selectJob", "Select a job");
      $("cyclesCount").textContent = "0";
      $("stdTotal").textContent = "-";
      $("stdExplain").textContent = t("recordCycles", "Record cycles to compute.");
      $("stabilityText").textContent = t("noData", "No data");
      $("avgCycleObs").textContent = "-";
      $("medianCycle").textContent = "-";
      $("p90Cycle").textContent = "-";
      $("bestWorstCycle").textContent = "-";
      $("cvCycle").textContent = "-";
      $("throughputCycle").textContent = "-";
      $("kpiActionBody").innerHTML = `<tr><td colspan="5" class="muted">No action data.</td></tr>`;
      $("mainBtn").disabled = true;
      $("finishCycleBtn").disabled = true;
    } else {
      const st = getStationById(job.stationId);
      $("jobHeader").innerHTML =
        `<span class="pill">Station</span> <strong>${esc(st?.code||"")} - ${esc(st?.name||"")}</strong>
         <span class="pill">Job</span> <strong>${esc(job.name)}</strong>`;
      const hjl = $("hJobLabel");
      if (hjl) hjl.textContent = `${st?.code ? st.code + " · " : ""}${job.name}`;
      const filteredCycles = (job.cycles || []).filter((c) => tagSet.has(c.tag || "Normal"));
      const cycleStats = computeCycleStats(job, filteredCycles);
      $("cyclesCount").textContent = filteredCycles.length === job.cycles.length
        ? String(filteredCycles.length)
        : `${filteredCycles.length}/${job.cycles.length}`;

      $("stabilityText").textContent = cycleStats?.stability || "No data";
      if (!cycleStats) {
        $("stdTotal").textContent = "-";
        $("stdExplain").textContent = t("recordCycles", "Record cycles to compute.");
        $("avgCycleObs").textContent = "-";
        $("medianCycle").textContent = "-";
        $("p90Cycle").textContent = "-";
        $("bestWorstCycle").textContent = "-";
        $("cvCycle").textContent = "-";
        $("throughputCycle").textContent = "-";
        $("kpiActionBody").innerHTML = `<tr><td colspan="5" class="muted">No action data.</td></tr>`;
      } else {
        $("stdTotal").textContent = fmtQtyMs(cycleStats.stdMs);
        $("stdExplain").textContent = `Rating ${job.ratingPct}% + Allowance ${job.allowancePct}% applied.`;
        $("avgCycleObs").textContent = fmtQtyMs(cycleStats.avgMs);
        $("medianCycle").textContent = fmtQtyMs(cycleStats.medianMs);
        $("p90Cycle").textContent = fmtQtyMs(cycleStats.p90Ms);
        $("bestWorstCycle").textContent = `${fmtQtyMs(cycleStats.bestMs)} / ${fmtQtyMs(cycleStats.worstMs)}`;
        $("cvCycle").textContent = `${(cycleStats.cv * 100).toFixed(1)} %`;
        $("throughputCycle").textContent = cycleStats.throughputPerHour == null
          ? "-"
          : `${cycleStats.throughputPerHour.toFixed(1)} cyc/h`;

        const rows = computeActionStats(job, filteredCycles, cycleStats.avgMs);
        if (!rows.length) {
          $("kpiActionBody").innerHTML = `<tr><td colspan="5" class="muted">No action data.</td></tr>`;
        } else {
          $("kpiActionBody").innerHTML = rows.map((r) => `
            <tr>
              <td>${esc(r.name)} <span class="muted">(${esc(getActionType(r.type).id)})</span></td>
              <td class="right mono">${fmtQtyMs(r.avgMs)}</td>
              <td class="right mono">${fmtQtyMs(r.minMs)}</td>
              <td class="right mono">${fmtQtyMs(r.maxMs)}</td>
              <td class="right mono">${r.sharePct.toFixed(1)}%</td>
            </tr>
          `).join("");
        }
      }
      $("mainBtn").disabled = job.elements.length === 0 || captureMode === "video";
      $("finishCycleBtn").disabled = !(timer.mode === "RUNNING");
    }

    // timer panel display
    $("undoBtn").disabled = !(timer.mode==="RUNNING" && timer.laps.length>0);

    if (!job || job.elements.length === 0) {
      $("curElName").textContent = "-";
      $("curElType").textContent = "-";
      $("curIndex").textContent = "-";
      $("curHint").textContent = job ? t("addElementsInConfig", "Add elements in Config") : t("selectJob", "Select a job");
      $("mainBtn").textContent = t("start", "Start");
      $("finishCycleBtn").disabled = true;
      if (!job) $("elapsed").textContent = "00:00.000";
    } else {
      if (captureMode === "video") {
        $("curElName").textContent = t("videoMode", "Video capture");
        $("curElType").textContent = t("markers", "Markers");
        $("curIndex").textContent = "-";
        $("curHint").textContent = t("videoHint", "Mark start/end, then create cycle from markers");
        $("mainBtn").textContent = t("videoMode", "Video mode");
        $("finishCycleBtn").disabled = true;
        $("elapsed").textContent = "00:00.000";
      } else if (timer.mode==="IDLE") {
        $("curElName").textContent = job.elements[0].name;
        $("curElType").textContent = job.elements[0].type;
        $("curIndex").textContent = `1 / ${job.elements.length}`;
        if (captureMode === "single") {
          const single = job.elements.find((e) => e.id === singleCaptureElementId) || job.elements[0];
          $("curElName").textContent = single.name;
          $("curElType").textContent = single.type;
          $("curIndex").textContent = t("singleMode", "Single action mode");
          $("curHint").textContent = t("singleHint", "Start, capture repeats, then Finish cycle");
        } else {
          $("curHint").textContent = t("pressStart", "Press Start");
        }
        $("mainBtn").textContent = t("start", "Start");
        $("finishCycleBtn").disabled = true;
        $("elapsed").textContent = "00:00.000";
      } else {
        if (timer.captureMode === "single") {
          const single = job.elements.find((e) => e.id === timer.singleElementId) || job.elements[0];
          $("curElName").textContent = single.name;
          $("curElType").textContent = single.type;
          $("curIndex").textContent = `${t("captures", "Captures")}: ${timer.laps.length}`;
          $("curHint").textContent = t("captureEachHint", "Capture each repeat, then Finish cycle");
          $("mainBtn").textContent = t("captureLap", "Capture lap");
          $("finishCycleBtn").disabled = false;
        } else {
          const idx = Math.min(timer.index, job.elements.length-1);
          const el = job.elements[idx];
          const isLast = idx === job.elements.length-1;
          $("curElName").textContent = el.name;
          $("curElType").textContent = el.type;
          $("curIndex").textContent = `${idx+1} / ${job.elements.length}`;
          $("curHint").textContent = isLast ? t("finishToSave", "Finish to save cycle") : t("tapNext", "Tap Next");
          $("mainBtn").textContent = isLast ? t("finishCycle", "Finish cycle") : t("next", "Next");
          $("finishCycleBtn").disabled = false;
        }
      }
    }

    // cycles list + graph
    renderCyclesAndGraph(job);
  }

  function renderCyclesAndGraph(job) {
    const cyclesBody = $("cyclesBody");
    const canvas = $("timelineChart");

    cyclesBody.innerHTML = "";
    const chipEl0 = $("cyclesShownChip");
    if (chipEl0) chipEl0.textContent = "0 cycles";
    const selChip0 = $("selCountChip");
    if (selChip0) selChip0.textContent = "0 sel.";
    $("chartLegend").innerHTML = "";

    if (!job || job.cycles.length === 0) {
      closeTimelineEditor();
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="6" class="muted">${esc(t("noCyclesRecorded", "No cycles recorded."))}</td>`;
      cyclesBody.appendChild(tr);
      drawEmpty(canvas.getContext("2d"), canvas.width, canvas.height, t("noCyclesRecorded", "No cycles"));
      return;
    }

    const tagSet = selectedTagsSet();
    const filteredCycles = job.cycles.filter(c => tagSet.has(c.tag || "Normal"));
    const chipEl = $("cyclesShownChip");
    if (chipEl) chipEl.textContent = filteredCycles.length === job.cycles.length
      ? `${filteredCycles.length} cycle${filteredCycles.length===1?"":"s"}`
      : `${filteredCycles.length} / ${job.cycles.length} cycles`;
    const selChip = $("selCountChip");
    if (selChip) selChip.textContent = `${selectedCycleIdsForLine.size} sel.`;

    if (!selectedCycleId || !job.cycles.some(c => c.id === selectedCycleId)) {
      selectedCycleId = job.cycles[job.cycles.length-1].id;
    }
    if (selectedCycleIdsForLine.size === 0) {
      const base = filteredCycles.length ? filteredCycles : job.cycles;
      selectedCycleIdsForLine = new Set(base.slice(-3).map(c => c.id));
    }
    boundLineSelection(job, 6);

    // cycles table (most recent first) + inline detail row
    const reversed = job.cycles.slice().reverse();
    for (let idxFromEnd=0; idxFromEnd<reversed.length; idxFromEnd++){
      const c = reversed[idxFromEnd];
      const number = job.cycles.length - idxFromEnd;
      const isActive = c.id === selectedCycleId;
      const checked = selectedCycleIdsForLine.has(c.id);
      const tagVal = c.tag || "Normal";
      const tagOptions = TAGS.map(t => `<option value="${t}" ${t===tagVal?"selected":""}>${t}</option>`).join("");

      const tr = document.createElement("tr");
      tr.style.cursor="pointer";
      tr.style.background = isActive ? accentRgba(0.10) : "transparent";
      if (!tagSet.has(tagVal)) tr.style.opacity = "0.55";

      tr.innerHTML = `
        <td class="right"><input class="checkbox" type="checkbox" ${checked?"checked":""} data-check="1" /></td>
        <td class="mono">${number}</td>
        <td class="muted">${new Date(c.atIso).toLocaleString()}</td>
        <td><select data-tag="1">${tagOptions}</select></td>
        <td class="right mono">${fmtQtyMs(c.totalMs)}</td>
        <td class="right"><button class="danger" data-del="1" style="padding:6px 10px; border-radius:10px;">Delete</button></td>
      `;

      tr.addEventListener("click", (e) => {
        // ignore clicks on inputs/selects/textareas/buttons except our special data attributes
        const interactive = e.target.closest("input,textarea,select,button");
        if (interactive && !e.target.dataset.del && !e.target.dataset.check && !e.target.dataset.tag) {
          return; // allow typing without toggling
        }
        if (e.target?.dataset?.del) { e.stopPropagation(); deleteCycleById(c.id); return; }
        if (e.target?.dataset?.check) { e.stopPropagation(); toggleLineSelection(c.id, e.target.checked); return; }
        if (e.target?.dataset?.tag) { e.stopPropagation(); setCycleTag(c.id, e.target.value); return; }
        // Toggle inline details open/close without changing global selection
        if (openInlineCycleIds.has(c.id)) openInlineCycleIds.delete(c.id);
        else openInlineCycleIds.add(c.id);
        renderAll();
      });

      cyclesBody.appendChild(tr);

      if (openInlineCycleIds.has(c.id)) {
        const schedule = resolveCycleSchedule(job, c);
        const segByEl = new Map(schedule.segments.map((s) => [s.elementId, s]));
        const qStep = String(timeResolutionSec());
        const qDec = timeDecimals("s");
        
        const inline = document.createElement("tr");
        inline.className = "cycleInlineDetailRow";
        
        // Build element detail table HTML
        const elementsTableHtml = (job.elements || []).map((el, i) => {
          const seg = segByEl.get(el.id);
          const startSec = quantizeSec(seg ? seg.startSec : 0);
          const endSec = quantizeSec(seg ? seg.endSec : 0);
          const durSec = quantizeSec(seg ? seg.durSec : 0);
          return `
            <tr>
              <td class="mono">${i+1}</td>
              <td>${esc(el.name)}</td>
              <td><span class="pill">${esc(el.type)}</span></td>
              <td class="right">
                <input
                  class="videoNum"
                  data-cycle-edit="start"
                  data-cycle-id="${esc(c.id)}"
                  data-element-id="${esc(el.id)}"
                  type="number"
                  min="0"
                  step="${qStep}"
                  value="${startSec.toFixed(qDec)}"
                />
              </td>
              <td class="right">
                <input
                  class="videoNum"
                  data-cycle-edit="end"
                  data-cycle-id="${esc(c.id)}"
                  data-element-id="${esc(el.id)}"
                  type="number"
                  min="0"
                  step="${qStep}"
                  value="${endSec.toFixed(qDec)}"
                />
              </td>
              <td class="right">
                <input
                  class="videoNum"
                  data-cycle-edit="dur"
                  data-cycle-id="${esc(c.id)}"
                  data-element-id="${esc(el.id)}"
                  type="number"
                  min="0"
                  step="${qStep}"
                  value="${durSec.toFixed(qDec)}"
                />
              </td>
            </tr>
          `;
        }).join("");
        
        inline.innerHTML = `
          <td colspan="6">
            <div class="cycleInlineDetail">
              <div class="cycleInlineHead" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <span class="small muted">Cycle @ ${new Date(c.atIso).toLocaleString()} - ${c.tag || "Normal"}</span>
                <span class="pill mono">${fmtQtyMs(c.totalMs)}</span>
              </div>
              
              <label style="margin-top:10px; display:block;">Notes (optional)</label>
              <textarea 
                id="cycleNoteBox_${esc(c.id)}"
                class="cycleNoteInput"
                data-cycle-id="${esc(c.id)}"
                placeholder="e.g., paused, missing part, machine jam..."
                style="width:100%; min-height:60px; margin-bottom:10px;"
              >${esc(c.note || "")}</textarea>
              
              <div class="small muted" style="margin-bottom:10px;">Notes stored locally + JSON.</div>
              
              <div class="scrollBox noScroll">
                <table>
                  <thead>
                    <tr>
                      <th style="width:38px;">#</th>
                      <th>Element</th>
                      <th style="width:140px;">Type</th>
                      <th class="right" style="width:110px;">Start s</th>
                      <th class="right" style="width:110px;">End s</th>
                      <th class="right" style="width:120px;">Dur s</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${elementsTableHtml}
                    <tr>
                      <td colspan="5" class="right muted">Total</td>
                      <td class="right mono"><strong>${fmtQtyMs(c.totalMs)}</strong></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </td>
        `;
        cyclesBody.appendChild(inline);
      }
    }

    // graph model base cycles = filtered (pro behavior)
    const baseCycles = filteredCycles.length ? filteredCycles : job.cycles;
    const perElVals = perElementValues(job, baseCycles);
    const avgByElSec = new Map();
    for (const el of job.elements) {
      const secArr = (perElVals.get(el.id)||[]).map(x=>x/1000);
      avgByElSec.set(el.id, mean(secArr));
    }
    const outModel = buildOutlierModel(job, baseCycles, $("outlierModeSel").value);

    const selectedCycles = job.cycles
      .filter(c => selectedCycleIdsForLine.has(c.id))
      .filter(c => tagSet.has(c.tag || "Normal"))
      .slice(-6);

    const rowsForHeight = (graphMode === "ALL")
      ? Math.max(1, Math.min(16, baseCycles.length))
      : Math.max(1, selectedCycles.length);
    const laneCount = Math.max(1, new Set((job.elements || []).map((el) => String(getActionType(el.type).lane || "lane"))).size);
    const sameBase = !!state.ui?.timelineSameBase;
    const maxCfgHeight = Math.max(6, ...((job.elements || []).map((el) => Math.max(2, Number(getActionType(el.type).heightPx || 6)))));
    const laneStep = (sameBase || laneCount <= 1) ? 0 : Math.max(6, Math.round(maxCfgHeight * 0.65));
    const rowTarget = maxCfgHeight + Math.max(0, laneCount - 1) * laneStep + 18;
    const desiredCanvasH = Math.max(480, Math.min(1200, 180 + rowsForHeight * rowTarget));
    if (canvas.height !== Math.round(desiredCanvasH)) {
      canvas.height = Math.round(desiredCanvasH);
    }

    drawTimeline(
      canvas,
      job,
      baseCycles,
      selectedCycles,
      avgByElSec,
      outModel,
      $("showAvgLineChk").checked,
      $("showOutliersChk").checked
    );
    syncTimelineEditor();
    renderLegend(job);
  }

  function onTimelinePointerDown(e) {
    if (graphMode !== "SELECTED") return;
    const canvas = $("timelineChart");
    const geom = timelineEditState.geom;
    const job = getActiveJob();
    if (!canvas || !geom || !job) return;
    const p = toCanvasPoint(canvas, e);
    if (!p) return;
    const hit = findTimelineHit(geom, p.x, p.y);
    if (!hit) return;

    const edgePad = 8;
    const nearEnd = Math.abs(p.x - hit.x1) <= edgePad;
    timelineEditState.drag = {
      cycleId: hit.cycleId,
      elementId: hit.elementId,
      x0: p.x,
      initialMs: Number(hit.sec || 0) * 1000,
      initialStartMs: Number(hit.startSec || 0) * 1000,
      mode: nearEnd ? "resizeEnd" : "drag",
      moved: false,
    };
    try { canvas.setPointerCapture?.(e.pointerId); } catch {}
    e.preventDefault();
  }

  function onTimelinePointerMove(e) {
    const canvas = $("timelineChart");
    const geom = timelineEditState.geom;
    const job = getActiveJob();
    const tooltip = $("tlTooltip");
    if (!canvas || !geom) { if (tooltip) { tooltip.classList.remove("show"); } return; }
    const p = toCanvasPoint(canvas, e);
    if (!p) { if (tooltip) tooltip.classList.remove("show"); return; }

    const drag = timelineEditState.drag;
    if (!drag || !job) {
      const hit = findTimelineHit(geom, p.x, p.y);
      if (!hit || graphMode !== "SELECTED") {
        canvas.style.cursor = "default";
        if (tooltip) tooltip.classList.remove("show");
        return;
      }
      const edgePad = 8;
      const nearEnd = Math.abs(p.x - hit.x1) <= edgePad;
      canvas.style.cursor = nearEnd ? "ew-resize" : "move";

      // Show tooltip
      if (tooltip && job) {
        const el = job.elements.find(e => e.id === hit.elementId);
        const at = el ? getActionType(el.type) : null;
        const cycle = job.cycles.find(c => c.id === hit.cycleId);
        const cycleDate = cycle ? new Date(cycle.atIso).toLocaleString() : "";
        const outModel = buildOutlierModel(job, getFilteredCyclesForJob(job), $("outlierModeSel")?.value || "MULT_1_5");
        const m = outModel.get(hit.elementId);
        const isOut = m ? (m.mode === "MULT_1_5" ? hit.sec > m.hi : (hit.sec < (m.lo||0)) || hit.sec > m.hi) : false;
        tooltip.innerHTML = [
          el ? `<div class="tt-el">${esc(el.name)}</div>` : "",
          at ? `<div class="tt-row" style="color:var(--muted);">${esc(at.name)} · ${esc(at.lane)}</div>` : "",
          `<div class="tt-val">${fmtQtySec(hit.sec)} &nbsp; <span style="color:var(--muted);">(${hit.startSec.toFixed(3)}→${hit.endSec.toFixed(3)}s)</span></div>`,
          cycleDate ? `<div class="tt-row">${cycleDate}</div>` : "",
          isOut ? `<div class="tt-outlier">⚠ Outlier</div>` : "",
        ].filter(Boolean).join("");
        tooltip.classList.add("show");
        tooltip.style.left = (e.clientX + 14) + "px";
        tooltip.style.top = (e.clientY - 10) + "px";
        // Keep in viewport
        requestAnimationFrame(() => {
          const r = tooltip.getBoundingClientRect();
          if (r.right > window.innerWidth - 8) tooltip.style.left = (e.clientX - r.width - 14) + "px";
          if (r.bottom > window.innerHeight - 8) tooltip.style.top = (e.clientY - r.height + 10) + "px";
        });
      }
      return;
    }

    if (tooltip) tooltip.classList.remove("show");
    const dx = p.x - drag.x0;
    const deltaSec = timelineSecDelta(geom, dx);
    if (Math.abs(dx) > 1.5) drag.moved = true;
    if (drag.mode === "drag") {
      const nextStartMs = Math.max(0, Number(drag.initialStartMs || 0) + (deltaSec * 1000));
      if (setCycleElementOffsetMs(job, drag.cycleId, drag.elementId, nextStartMs)) {
        selectedCycleId = drag.cycleId;
        renderAll();
      }
      return;
    }

    let nextMs = drag.initialMs + (deltaSec * 1000);
    nextMs = Math.max(0, nextMs);
    if (setCycleElementDurationMs(job, drag.cycleId, drag.elementId, nextMs)) {
      selectedCycleId = drag.cycleId;
      renderAll();
    }
  }

  function onTimelinePointerUp() {
    const canvas = $("timelineChart");
    if (canvas) canvas.style.cursor = "default";
    if (!timelineEditState.drag) return;
    if (timelineEditState.drag.moved) timelineEditState.lastDragTs = Date.now();
    timelineEditState.drag = null;
    saveState();
  }

  function closeTimelineEditor() {
    timelineEditState.editor.open = false;
    timelineEditState.editorDrag = null;
    const box = $("timelineBarEditor");
    if (box) box.classList.remove("show");
  }

  function openTimelineEditor(hit, x = 0, y = 0) {
    if (!hit) return closeTimelineEditor();
    timelineEditState.editor = {
      open: true,
      cycleId: String(hit.cycleId || ""),
      elementId: String(hit.elementId || ""),
      x: Number(x || 0),
      y: Number(y || 0),
      manualPos: false,
      lastField: "",
    };
    syncTimelineEditor();
  }

  function syncTimelineEditor() {
    const box = $("timelineBarEditor");
    const card = $("timelineChartCard");
    const canvas = $("timelineChart");
    const job = getActiveJob();
    if (!box || !card || !canvas || !job) return closeTimelineEditor();
    const ed = timelineEditState.editor;
    if (!ed.open) return closeTimelineEditor();
    const geom = timelineEditState.geom;
    const hit = (geom?.hits || []).find((h) => h.cycleId === ed.cycleId && h.elementId === ed.elementId);
    if (!hit) return closeTimelineEditor();
    const cycle = (job.cycles || []).find((c) => c.id === ed.cycleId);
    const el = (job.elements || []).find((e) => e.id === ed.elementId);
    if (!cycle || !el) return closeTimelineEditor();

    const title = $("tlEdTitle");
    const meta = $("tlEdMeta");
    const iStart = $("tlEdStart");
    const iDur = $("tlEdDur");
    const iEnd = $("tlEdEnd");
    if (title) title.textContent = `${el.name} (${el.type})`;
    if (meta) meta.textContent = `${new Date(cycle.atIso).toLocaleTimeString()} - cycle #${(job.cycles || []).findIndex((c) => c.id === cycle.id) + 1}`;
    const dec = timeDecimals("s");
    const step = String(timeResolutionSec());
    if (iStart) { iStart.value = Number(hit.startSec || 0).toFixed(dec); iStart.step = step; }
    if (iDur) { iDur.value = Number(hit.sec || 0).toFixed(dec); iDur.step = step; }
    if (iEnd) { iEnd.value = Number(hit.endSec || 0).toFixed(dec); iEnd.step = step; }

    const sx = card.clientWidth / canvas.width;
    const sy = card.clientHeight / canvas.height;
    let px = 8;
    let py = 8;
    if (ed.manualPos) {
      px = Number(ed.x || 8);
      py = Number(ed.y || 8);
    } else {
      const anchorX = ed.x || hit.x1;
      const anchorY = ed.y || hit.y;
      px = Math.max(8, Math.round(anchorX * sx) + 10);
      py = Math.max(8, Math.round(anchorY * sy) + 10);
    }

    box.style.left = `${px}px`;
    box.style.top = `${py}px`;
    box.classList.add("draggable");
    box.classList.add("show");

    // clamp after visible
    const bw = box.offsetWidth || 300;
    const bh = box.offsetHeight || 180;
    const maxL = Math.max(8, card.clientWidth - bw - 8);
    const maxT = Math.max(8, card.clientHeight - bh - 8);
    const clampedL = Math.max(8, Math.min(maxL, px));
    const clampedT = Math.max(8, Math.min(maxT, py));
    box.style.left = `${clampedL}px`;
    box.style.top = `${clampedT}px`;
    if (ed.manualPos) {
      ed.x = clampedL;
      ed.y = clampedT;
    }
  }

  function applyTimelineEditorInputs(sourceField = "") {
    const job = getActiveJob();
    const ed = timelineEditState.editor;
    if (!job || !ed?.open) return;
    const s = Math.max(0, Number($("tlEdStart")?.value || 0));
    const dRaw = Math.max(0, Number($("tlEdDur")?.value || 0));
    const e = Math.max(0, Number($("tlEdEnd")?.value || 0));
    const fallbackDur = Math.max(0, e - s);
    const field = String(sourceField || ed.lastField || "");
    let d = dRaw;
    if (field === "end") d = fallbackDur;
    else if (field === "dur") d = dRaw;
    else if (field === "start") d = dRaw > 0 ? dRaw : fallbackDur;
    else d = dRaw > 0 ? dRaw : fallbackDur;
    setCycleElementOffsetMs(job, ed.cycleId, ed.elementId, s * 1000);
    setCycleElementDurationMs(job, ed.cycleId, ed.elementId, d * 1000);
    selectedCycleId = ed.cycleId;
    saveState();
    renderAll();
  }

  function beginTimelineEditorDrag(e) {
    const box = $("timelineBarEditor");
    const card = $("timelineChartCard");
    const ed = timelineEditState.editor;
    if (!box || !card || !ed?.open) return;
    if (typeof e.button === "number" && e.button !== 0) return;
    if (e.target?.closest("input,button,select,textarea,label")) return;
    const rect = box.getBoundingClientRect();
    timelineEditState.editorDrag = {
      pointerId: e.pointerId,
      dx: e.clientX - rect.left,
      dy: e.clientY - rect.top,
    };
    try { box.setPointerCapture?.(e.pointerId); } catch {}
    e.preventDefault();
  }

  function onTimelineEditorDragMove(e) {
    const drag = timelineEditState.editorDrag;
    const box = $("timelineBarEditor");
    const card = $("timelineChartCard");
    const ed = timelineEditState.editor;
    if (!drag || !box || !card || !ed?.open) return;
    const cardRect = card.getBoundingClientRect();
    let left = e.clientX - cardRect.left - drag.dx;
    let top = e.clientY - cardRect.top - drag.dy;
    const bw = box.offsetWidth || 300;
    const bh = box.offsetHeight || 180;
    const maxL = Math.max(8, card.clientWidth - bw - 8);
    const maxT = Math.max(8, card.clientHeight - bh - 8);
    left = Math.max(8, Math.min(maxL, left));
    top = Math.max(8, Math.min(maxT, top));
    box.style.left = `${Math.round(left)}px`;
    box.style.top = `${Math.round(top)}px`;
    ed.manualPos = true;
    ed.x = Math.round(left);
    ed.y = Math.round(top);
    e.preventDefault();
  }

  function endTimelineEditorDrag(e) {
    const box = $("timelineBarEditor");
    if (!timelineEditState.editorDrag) return;
    try { box?.releasePointerCapture?.(e.pointerId); } catch {}
    timelineEditState.editorDrag = null;
  }

  function onTimelineClick(e) {
    if (Date.now() - Number(timelineEditState.lastDragTs || 0) < 180) return;
    const canvas = $("timelineChart");
    const geom = timelineEditState.geom;
    if (!canvas || !geom) return;
    const p = toCanvasPoint(canvas, e);
    if (!p) return;
    const hit = findTimelineHit(geom, p.x, p.y);
    if (!hit) {
      closeTimelineEditor();
      return;
    }
    openTimelineEditor(hit, p.x, p.y);
  }

  // ----- Backup / UI wiring -----
  $("newStationBtn").addEventListener("click", createStation);
  const collapseStationsBtn = $("collapseStationsBtn");
  if (collapseStationsBtn) collapseStationsBtn.addEventListener("click", () => setAllStationsCollapsed(true));
  const expandStationsBtn = $("expandStationsBtn");
  if (expandStationsBtn) expandStationsBtn.addEventListener("click", () => setAllStationsCollapsed(false));

  $("searchBox").addEventListener("input", () => { searchText = $("searchBox").value || ""; renderStationJobSidebar(); });
  $("clearSearchBtn").addEventListener("click", () => { $("searchBox").value=""; searchText=""; renderStationJobSidebar(); });

  $("openDrawerBtn").addEventListener("click", openDrawer);
  $("closeDrawerBtn").addEventListener("click", closeDrawer);
  $("drawerOverlay").addEventListener("click", closeDrawer);
  $("drawerBody").addEventListener("click", (e) => {
    const btn = e.target?.closest?.("[data-drawer-sec-btn]");
    if (!btn) return;
    const sec = String(btn.dataset.drawerSecBtn || "");
    if (!sec) return;
    ensureUiState(state);
    state.ui.drawerSections[sec] = !(state.ui.drawerSections[sec] !== false);
    applyDrawerSectionsUi();
    saveState();
  });
  const toggleLeftPanelBtn = $("toggleLeftPanelBtn");
  if (toggleLeftPanelBtn) {
    toggleLeftPanelBtn.addEventListener("click", () => {
      state.ui.leftPanelVisible = !state.ui.leftPanelVisible;
      applyUiLayout();
      saveState();
    });
  }
  const uiScaleRange = $("uiScaleRange");
  if (uiScaleRange) {
    uiScaleRange.addEventListener("input", () => {
      const v = Number(uiScaleRange.value || 100) / 100;
      setUiScale(v);
      saveState();
    });
  }
  const uiScaleInput = $("uiScaleInput");
  if (uiScaleInput) {
    uiScaleInput.addEventListener("change", () => {
      const v = Number(uiScaleInput.value || 1);
      setUiScale(v);
      saveState();
    });
  }
  const uiLayoutModeSel = $("uiLayoutModeSel");
  if (uiLayoutModeSel) {
    uiLayoutModeSel.addEventListener("change", () => {
      state.ui.layoutMode = (uiLayoutModeSel.value === "vertical") ? "vertical" : "horizontal";
      applyUiLayout();
      saveState();
    });
  }
  const uiPanelLayoutSel = $("uiPanelLayoutSel");
  if (uiPanelLayoutSel) {
    uiPanelLayoutSel.addEventListener("change", () => {
      state.ui.panelLayout = (uiPanelLayoutSel.value === "grid") ? "grid" : "stack";
      applyUiLayout();
      saveState();
    });
  }
  const quickPanelLayoutSel = $("quickPanelLayoutSel");
  if (quickPanelLayoutSel) {
    quickPanelLayoutSel.addEventListener("change", () => {
      state.ui.panelLayout = (quickPanelLayoutSel.value === "grid") ? "grid" : "stack";
      applyUiLayout();
      saveState();
    });
  }
  const uiPanelGridColsRange = $("uiPanelGridColsRange");
  if (uiPanelGridColsRange) {
    uiPanelGridColsRange.addEventListener("input", () => {
      state.ui.panelGridCols = Math.max(1, Math.min(4, Number(uiPanelGridColsRange.value) || 2));
      applyUiLayout();
      saveState();
    });
  }
  const uiJobsWidthRange = $("uiJobsWidthRange");
  if (uiJobsWidthRange) {
    uiJobsWidthRange.addEventListener("input", () => {
      state.ui.jobsPanelWidth = Math.max(240, Math.min(640, Number(uiJobsWidthRange.value || 360) || 360));
      applyUiLayout();
      saveState();
    });
  }
  const uiBgColor = $("uiBgColor");
  if (uiBgColor) {
    uiBgColor.addEventListener("input", () => {
      state.ui.themeBg = toHex6(uiBgColor.value, "#0b0c10");
      applyUiLayout();
      saveState();
    });
  }
  const uiTextColor = $("uiTextColor");
  if (uiTextColor) {
    uiTextColor.addEventListener("input", () => {
      state.ui.themeText = toHex6(uiTextColor.value, "#e8e8e8");
      applyUiLayout();
      saveState();
    });
  }
  const uiAccentColor = $("uiAccentColor");
  if (uiAccentColor) {
    uiAccentColor.addEventListener("input", () => {
      state.ui.themeAccent = toHex6(uiAccentColor.value, "#4c73ff");
      applyUiLayout();
      saveState();
    });
  }
  const uiTimeUnitSel = $("uiTimeUnitSel");
  if (uiTimeUnitSel) {
    uiTimeUnitSel.addEventListener("change", () => {
      state.ui.timeDisplayUnit = (uiTimeUnitSel.value === "min") ? "min" : "s";
      saveState();
      renderAll();
    });
  }
  const uiTimeResolutionSel = $("uiTimeResolutionSel");
  if (uiTimeResolutionSel) {
    uiTimeResolutionSel.addEventListener("change", () => {
      const q = Number(uiTimeResolutionSel.value || 0.001);
      state.ui.timeResolutionSec = [1, 0.1, 0.01, 0.001].includes(q) ? q : 0.001;
      saveState();
      renderAll();
    });
  }
  const uiResetBtn = $("uiResetBtn");
  if (uiResetBtn) {
    uiResetBtn.addEventListener("click", () => {
      const keep = !!state.ui?.leftPanelVisible;
      state.ui = defaultUiState();
      state.ui.leftPanelVisible = keep;
      applyUiLayout();
      saveState();
      renderAll();
    });
  }
  const uiTimelineSameBaseChk = $("uiTimelineSameBaseChk");
  if (uiTimelineSameBaseChk) {
    uiTimelineSameBaseChk.addEventListener("change", () => {
      state.ui.timelineSameBase = !!uiTimelineSameBaseChk.checked;
      saveState();
      renderAll();
    });
  }
  $("panelTogglesRow").addEventListener("click", (e) => {
    const btn = e.target.closest("[data-panel-toggle]");
    const panel = btn?.dataset?.panelToggle;
    if (!panel) return;
    if (panel === "jobs") {
      state.ui.leftPanelVisible = !state.ui.leftPanelVisible;
      applyUiLayout();
      saveState();
      return;
    }
    if (!state.ui?.panels) return;
    state.ui.panels[panel] = !state.ui.panels[panel];
    applyUiLayout();
    saveState();
  });
  let draggingPanelId = "";
  const reorderablePanels = new Set((state.ui?.panelOrder || []).map((x) => String(x)));
  document.querySelectorAll("#panelTogglesRow [data-panel-toggle]").forEach((btn) => {
    const panelId = String(btn.dataset.panelToggle || "");
    const canDrag = reorderablePanels.has(panelId);
    btn.draggable = canDrag;
    if (!canDrag) return;
    btn.addEventListener("dragstart", (e) => {
      draggingPanelId = String(btn.dataset.panelToggle || "");
      e.dataTransfer?.setData("text/plain", draggingPanelId);
    });
    bindPanelDropTarget(btn, (x) => x.dataset.panelToggle);
    btn.addEventListener("dragend", () => { draggingPanelId = ""; });
  });

  document.querySelectorAll("#panelDock .panelBlock").forEach((block) => {
    const panelId = block.id.replace(/^panel/, "").replace(/Block$/, "").toLowerCase();
    block.setAttribute("draggable", "true");
    block.dataset.panelId = panelId;
    block.addEventListener("dragstart", (e) => {
      draggingPanelId = panelId;
      block.classList.add("dragging");
      e.dataTransfer?.setData("text/plain", panelId);
    });
    bindPanelDropTarget(block, (x) => x.dataset.panelId);
    block.addEventListener("dragend", () => {
      block.classList.remove("dragging");
      draggingPanelId = "";
    });
  });
  document.querySelectorAll("#panelDock .panelHdr[data-panel-hdr]").forEach((hdr) => {
    const panelId = String(hdr.dataset.panelHdr || "");
    if (!reorderablePanels.has(panelId)) return;
    hdr.draggable = true;
    hdr.addEventListener("dragstart", (e) => {
      draggingPanelId = panelId;
      hdr.classList.add("dragging");
      e.dataTransfer?.setData("text/plain", panelId);
    });
    hdr.addEventListener("dragover", (e) => {
      e.preventDefault();
      hdr.classList.add("dropBefore");
    });
    hdr.addEventListener("dragleave", () => hdr.classList.remove("dropBefore"));
    hdr.addEventListener("drop", (e) => {
      e.preventDefault();
      const src = draggingPanelId || e.dataTransfer?.getData("text/plain") || "";
      reorderPanels(src, panelId);
      hdr.classList.remove("dropBefore");
      draggingPanelId = "";
    });
    hdr.addEventListener("dragend", () => {
      hdr.classList.remove("dragging");
      hdr.classList.remove("dropBefore");
      draggingPanelId = "";
    });
  });
  document.querySelectorAll("[data-ui-panel]").forEach((btn) => {
    btn.addEventListener("click", (e) => {
      const panel = e.currentTarget?.dataset?.uiPanel;
      if (!panel || !state.ui?.panels) return;
      state.ui.panels[panel] = !state.ui.panels[panel];
      applyUiLayout();
      saveState();
    });
  });

  // Panel collapse/expand via header buttons
  document.querySelectorAll(".panelHdr[data-panel-hdr]").forEach((btn) => {
    btn.addEventListener("click", () => {
      const panelId = String(btn.dataset.panelHdr || "");
      if (panelId === "jobsSidebar") {
        state.ui.jobsPanelCollapsed = !state.ui.jobsPanelCollapsed;
        applyUiLayout();
        saveState();
        return;
      }
      const block = btn.closest(".panelBlock");
      if (block) block.classList.toggle("collapsed");
    });
  });

  $("newJobBtn").addEventListener("click", createJob);
  $("dupJobBtn").addEventListener("click", duplicateActiveJob);
  $("delJobBtn").addEventListener("click", deleteActiveJob);

  // Job quick-switch
  const jobSwitchSel = $("jobSwitchSel");
  if (jobSwitchSel) {
    jobSwitchSel.addEventListener("change", () => {
      const id = jobSwitchSel.value;
      if (id && state.jobs.some(j => j.id === id)) selectJob(id);
    });
  }
  const timelineStationSel = $("timelineStationSel");
  if (timelineStationSel) {
    timelineStationSel.addEventListener("change", () => {
      const stationId = String(timelineStationSel.value || "");
      const nextJob = state.jobs.find((j) => j.stationId === stationId);
      if (nextJob) {
        selectJob(nextJob.id);
        return;
      }
      if (timer.mode === TimerMode.Running) {
        if (!confirm("Timer running. Switch station and stop current cycle?")) return;
        stopCycle();
      }
      state.activeJobId = null;
      selectedElementId = null;
      selectedCycleId = null;
      selectedCycleIdsForLine = new Set();
      saveState();
      renderAll();
    });
  }
  const timelineJobSel = $("timelineJobSel");
  if (timelineJobSel) {
    timelineJobSel.addEventListener("change", () => {
      const id = String(timelineJobSel.value || "");
      if (id && state.jobs.some((j) => j.id === id)) selectJob(id);
    });
  }

  // Theme preset buttons
  const THEME_PRESETS = {
    dark:     { bg:"#0b0c10", text:"#e8e8e8", accent:"#4c73ff" },
    midnight: { bg:"#060a1a", text:"#d0e4f8", accent:"#33cfff" },
    forest:   { bg:"#0a120a", text:"#cce8cc", accent:"#42d18b" },
    ember:    { bg:"#120a0a", text:"#f0e0d0", accent:"#ff6b35" },
    light:    { bg:"#f0f2f5", text:"#1a1c22", accent:"#4c73ff" },
  };
  document.querySelectorAll(".tpBtn[data-tp]").forEach(btn => {
    btn.addEventListener("click", () => {
      const p = THEME_PRESETS[btn.dataset.tp]; if (!p) return;
      state.ui.themeBg = p.bg;
      state.ui.themeText = p.text;
      state.ui.themeAccent = p.accent;
      applyUiLayout(); saveState(); syncViewLayoutInputs();
      document.querySelectorAll(".tpBtn").forEach(b => b.classList.remove("tpActive"));
      btn.classList.add("tpActive");
    });
  });

  $("jobStationSelect").addEventListener("change", () => {
    const job = getActiveJob(); if (!job) return;
    job.stationId = $("jobStationSelect").value;
    saveState(); renderAll();
  });
  $("jobName").addEventListener("input", () => {
    const job = getActiveJob(); if (!job) return;
    job.name = $("jobName").value;
    saveState(); renderAll();
  });
  $("allowancePct").addEventListener("input", () => {
    const job = getActiveJob(); if (!job) return;
    job.allowancePct = Number($("allowancePct").value || 0);
    saveState(); renderAll();
  });
  $("ratingPct").addEventListener("input", () => {
    const job = getActiveJob(); if (!job) return;
    job.ratingPct = Number($("ratingPct").value || 100);
    saveState(); renderAll();
  });
  $("elType").addEventListener("change", () => {
    const job = getActiveJob();
    if (!job || !selectedElementId) return;
    const el = job.elements.find((e) => e.id === selectedElementId);
    if (!el) return;
    el.type = String($("elType").value || el.type).toUpperCase();
    saveState();
    renderAll();
  });

  $("addElBtn").addEventListener("click", addElement);
  $("deleteElBtn").addEventListener("click", deleteSelectedElement);
  $("moveUpBtn").addEventListener("click", () => moveSelectedElement(-1));
  $("moveDownBtn").addEventListener("click", () => moveSelectedElement(+1));
  $("addActionTypeBtn").addEventListener("click", upsertActionTypeFromInputs);
  const clearTypeFormBtn = $("clearTypeFormBtn");
  if (clearTypeFormBtn) clearTypeFormBtn.addEventListener("click", () => {
    editingActionTypeId = null;
    $("atId").value = "";
    $("atName").value = "";
    $("atLane").value = "";
    $("atColor").value = "#4c73ff";
    $("atHeight").value = "6";
    $("atLaneOrder").value = "0";
    $("atZ").value = "10";
    $("atOpacity").value = "100";
    $("atUnderlay").value = "";
    $("atStackFlow").checked = true;
    $("atResourceMode").value = "AUTO";
    updateAddTypeButton();
  });
  const kpiExportCsvBtn = $("kpiExportCsvBtn");
  if (kpiExportCsvBtn) kpiExportCsvBtn.addEventListener("click", exportKpiActionsCsv);
  const kpiPrintBtn = $("kpiPrintBtn");
  if (kpiPrintBtn) kpiPrintBtn.addEventListener("click", openPrintReport);
  $("captureModeSel").addEventListener("change", () => {
    refreshCaptureModeUI();
    renderAll();
  });
  $("singleActionSel").addEventListener("change", () => {
    singleCaptureElementId = String($("singleActionSel").value || "");
    renderAll();
  });

  $("mainBtn").addEventListener("click", () => {
    const job = getActiveJob(); if (!job) return;
    refreshCaptureModeUI();
    if (captureMode === "video") return;
    if (timer.mode === TimerMode.Idle) return startCycle();
    if (timer.captureMode === "single") return commitLapAndAdvance(false);
    const idx = Math.min(timer.index, job.elements.length - 1);
    const isLast = idx === job.elements.length - 1;
    commitLapAndAdvance(isLast);
  });
  $("finishCycleBtn").addEventListener("click", () => {
    if (timer.mode !== TimerMode.Running) return;
    commitLapAndAdvance(true);
  });
  $("undoBtn").addEventListener("click", undoLap);
  $("clearJobCyclesBtn").addEventListener("click", clearJobCycles);

  $("videoFile").addEventListener("change", (e) => {
    const f = e.target.files?.[0];
    if (f) loadVideoFile(f);
    e.target.value = "";
  });
  const videoLibLoadBtn = $("videoLibLoadBtn");
  if (videoLibLoadBtn) {
    videoLibLoadBtn.addEventListener("click", () => {
      const id = $("videoLibSel")?.value || "";
      if (!id) return alert("Select a recorded entry first.");
      loadVideoLibraryEntryIntoMarkers(id);
    });
  }
  const videoLibDeleteBtn = $("videoLibDeleteBtn");
  if (videoLibDeleteBtn) {
    videoLibDeleteBtn.addEventListener("click", () => {
      const sel = $("videoLibSel");
      const id = String(sel?.value || "");
      if (!id) return;
      if (!confirm("Delete this recorded bookmarks entry?")) return;
      const next = loadVideoBookmarksLibrary().filter((e) => String(e.id || "") !== id);
      saveVideoBookmarksLibrary(next);
      populateVideoLibrarySelector();
    });
  }
  const videoLibRefreshBtn = $("videoLibRefreshBtn");
  if (videoLibRefreshBtn) videoLibRefreshBtn.addEventListener("click", populateVideoLibrarySelector);
  $("videoSeqBtn").addEventListener("click", videoSequenceStep);
  $("videoManualStartBtn").addEventListener("click", videoMarkStart);
  $("videoManualEndBtn").addEventListener("click", videoMarkEnd);
  $("videoStackRulesChk").addEventListener("change", () => {
    renderVideoMarkersList();
    syncVideoTimeline();
  });
  $("videoAutoStackBtn").addEventListener("click", applyVideoAutoStack);
  $("videoClearBtn").addEventListener("click", clearVideoMarkers);
  $("videoApplyBtn").addEventListener("click", applyVideoMarkersToCycle);
  $("videoEl").addEventListener("loadedmetadata", syncVideoTimeline);
  $("videoEl").addEventListener("timeupdate", syncVideoTimeline);
  $("videoTimeline").addEventListener("input", () => {
    const video = $("videoEl");
    if (!video) return;
    video.currentTime = Number($("videoTimeline").value || 0);
    syncVideoTimeline();
  });
  $("videoMarkersList").addEventListener("click", (e) => {
    const t = e.target;
    const id = t?.dataset?.vdel || t?.dataset?.vns || t?.dataset?.vne;
    if (!id) return;
    const marker = videoCapture.markers.find((m) => m.id === id);
    if (!marker) return;
    if (t.dataset.vdel) {
      videoCapture.markers = videoCapture.markers.filter((m) => m.id !== id);
      if (videoCapture.editMarkerId === id) videoCapture.editMarkerId = "";
      for (const key of Object.keys(videoCapture.openByElementId)) {
        if (videoCapture.openByElementId[key] === id) delete videoCapture.openByElementId[key];
      }
      renderVideoMarkersList();
      return;
    }
    const video = $("videoEl");
    if (!video) return;
    const now = quantizeSec(Number(video.currentTime || 0));
    if (t.dataset.vns) marker.startSec = now;
    if (t.dataset.vne) marker.endSec = now;
    if (marker.endSec != null && Number(marker.endSec) < Number(marker.startSec)) {
      const tmp = marker.startSec;
      marker.startSec = marker.endSec;
      marker.endSec = tmp;
    }
    renderVideoMarkersList();
  });
  $("videoMarkersList").addEventListener("input", (e) => {
    const t = e.target;
    const id = t?.dataset?.vs || t?.dataset?.ve;
    if (!id) return;
    const marker = videoCapture.markers.find((m) => m.id === id);
    if (!marker) return;
    const val = quantizeSec(Math.max(0, Number(t.value || 0)));
    if (t.dataset.vs) marker.startSec = val;
    if (t.dataset.ve) marker.endSec = t.value === "" ? null : val;
    if (marker.endSec != null && Number(marker.endSec) < Number(marker.startSec)) {
      const tmp = marker.startSec;
      marker.startSec = marker.endSec;
      marker.endSec = tmp;
    }
    renderVideoMarkersList();
  });
  bindVideoBarInteractions();
  window.addEventListener("pointermove", onVideoPointerMove);
  window.addEventListener("pointerup", onVideoPointerUp);
  window.addEventListener("pointercancel", onVideoPointerUp);
  const timelineCanvas = $("timelineChart");
  if (timelineCanvas) {
    timelineCanvas.addEventListener("pointerdown", onTimelinePointerDown);
    timelineCanvas.addEventListener("pointermove", onTimelinePointerMove);
    timelineCanvas.addEventListener("pointerup", onTimelinePointerUp);
    timelineCanvas.addEventListener("pointercancel", onTimelinePointerUp);
    timelineCanvas.addEventListener("pointerleave", (e) => { onTimelinePointerUp(e); const tt=$("tlTooltip"); if(tt) tt.classList.remove("show"); });
    timelineCanvas.addEventListener("click", onTimelineClick);
  }
  $("tlEdCloseBtn").addEventListener("click", closeTimelineEditor);
  $("tlEdApplyBtn").addEventListener("click", () => applyTimelineEditorInputs("apply"));
  $("tlEdResetStartBtn").addEventListener("click", () => {
    const ed = timelineEditState.editor;
    const job = getActiveJob();
    if (!job || !ed?.open) return;
    setCycleElementOffsetMs(job, ed.cycleId, ed.elementId, 0);
    saveState();
    renderAll();
  });
  $("tlEdStart").addEventListener("input", () => {
    if (timelineEditState.editor?.open) timelineEditState.editor.lastField = "start";
  });
  $("tlEdDur").addEventListener("input", () => {
    if (timelineEditState.editor?.open) timelineEditState.editor.lastField = "dur";
  });
  $("tlEdEnd").addEventListener("input", () => {
    if (timelineEditState.editor?.open) timelineEditState.editor.lastField = "end";
  });
  $("tlEdStart").addEventListener("change", () => applyTimelineEditorInputs("start"));
  $("tlEdDur").addEventListener("change", () => applyTimelineEditorInputs("dur"));
  $("tlEdEnd").addEventListener("change", () => applyTimelineEditorInputs("end"));
  const timelineEditor = $("timelineBarEditor");
  if (timelineEditor) {
    timelineEditor.addEventListener("pointerdown", beginTimelineEditorDrag);
    timelineEditor.addEventListener("pointermove", onTimelineEditorDragMove);
    timelineEditor.addEventListener("pointerup", endTimelineEditorDrag);
    timelineEditor.addEventListener("pointercancel", endTimelineEditorDrag);
  }
  document.addEventListener("pointerdown", (e) => {
    const box = $("timelineBarEditor");
    if (!box || !timelineEditState.editor.open) return;
    if (box.contains(e.target)) return;
    if ($("timelineChart")?.contains(e.target)) return;
    closeTimelineEditor();
  });

  function setMode(mode) {
    graphMode = mode;
    $("modeSelectedBtn").classList.toggle("active", mode === "SELECTED");
    $("modeAllBtn").classList.toggle("active", mode === "ALL");
    const selTb = $("selectionToolbar");
    if (selTb) selTb.style.opacity = mode === "SELECTED" ? "1" : "0.45";
    renderAll();
  }
  $("modeSelectedBtn").addEventListener("click", () => setMode("SELECTED"));
  $("modeAllBtn").addEventListener("click", () => setMode("ALL"));
  // Public API for external integration / automation
  window.ChronoLayoutAPI = {
    getState: () => ({
      panelLayout: state.ui.panelLayout,
      panelGridCols: state.ui.panelGridCols,
      panelOrder: (state.ui.panelOrder || []).slice(),
      panels: { ...(state.ui.panels || {}) },
    }),
    setPanelLayout: (layout) => {
      state.ui.panelLayout = (layout === "grid") ? "grid" : "stack";
      applyUiLayout();
      saveState();
      return window.ChronoLayoutAPI.getState();
    },
    setGridColumns: (cols) => {
      state.ui.panelGridCols = Math.max(1, Math.min(4, Number(cols) || 2));
      applyUiLayout();
      saveState();
      return window.ChronoLayoutAPI.getState();
    },
    movePanel: (panelId, beforePanelId) => {
      reorderPanels(panelId, beforePanelId);
      return window.ChronoLayoutAPI.getState();
    },
    setPanelVisible: (panelId, visible) => {
      if (panelId === "jobs") {
        state.ui.leftPanelVisible = !!visible;
      } else if (state.ui.panels && panelId in state.ui.panels) {
        state.ui.panels[panelId] = !!visible;
      }
      applyUiLayout();
      saveState();
      return window.ChronoLayoutAPI.getState();
    },
    resetLayout: () => {
      const defaults = defaultUiState();
      state.ui.panelOrder = defaults.panelOrder.slice();
      state.ui.panelLayout = defaults.panelLayout;
      state.ui.panelGridCols = defaults.panelGridCols;
      state.ui.panels = { ...defaults.panels };
      applyUiLayout();
      saveState();
      return window.ChronoLayoutAPI.getState();
    },
  };


  // Init selection toolbar visibility
  { const selTb = $("selectionToolbar"); if (selTb) selTb.style.opacity = "1"; }

  const rerender = () => renderAll();
  $("showAvgLineChk").addEventListener("change", rerender);
  $("showOutliersChk").addEventListener("change", rerender);
  $("outlierModeSel").addEventListener("change", rerender);
  $("tagNormal").addEventListener("change", rerender);
  $("tagRework").addEventListener("change", rerender);
  $("tagTraining").addEventListener("change", rerender);
  $("tagDisturbance").addEventListener("change", rerender);

  $("selectLast3Btn").addEventListener("click", () => selectLastN(3));
  $("clearSelectionBtn").addEventListener("click", clearLineSelection);
  $("selectAllCyclesForLineBtn").addEventListener("click", selectAllVisibleCyclesNoCap);
  $("invertSelectionBtn").addEventListener("click", invertVisibleCyclesSelection);
  // Event delegation for cycle inline inputs
  $("cyclesBody").addEventListener("input", (e) => {
    if (e.target.classList.contains("cycleNoteInput")) {
      const cycleId = e.target.dataset.cycleId;
      setCycleNoteById(cycleId, e.target.value);
    }
    // Handle editable cycle element details (start/end/dur)
    if (e.target.classList.contains("videoNum") && e.target.dataset.cycleEdit) {
      applyInlineCycleDetailEdit(e.target);
    }
  });

  // Clicking the cycles table header toggles expand/collapse of visible inline details
  const cyclesThead = $("panelCyclesBlock")?.querySelector("table thead");
  if (cyclesThead) {
    cyclesThead.addEventListener("click", (e) => {
      const th = e.target.closest("th");
      if (!th) return;
      // ignore clicks on the header buttons (select/invert)
      if (th.querySelector("button")) return;
      toggleAllVisibleInline();
    });
  }

  $("exportJsonBtn").addEventListener("click", exportJson);
  $("importJsonBtn").addEventListener("click", () => $("importFile").click());
  $("importFile").addEventListener("change", (e) => {
    const f = e.target.files?.[0];
    if (f) importJson(f);
    e.target.value = "";
  });
  $("exportCsvBtn").addEventListener("click", exportCsv);
  $("demoSmallBtn").addEventListener("click", () => loadDemo("./chrono_examples_small.json", "Demo Small"));
  $("demoMediumBtn").addEventListener("click", () => loadDemo("./chrono_examples_medium.json", "Demo Medium"));
  $("demoLargeBtn").addEventListener("click", () => loadDemo("./chrono_examples_large.json", "Demo Large"));
  $("clearLocalBtn").addEventListener("click", clearLocalState);

  window.addEventListener("keydown", (e) => {
    const t = e.target;
    const tag = String(t?.tagName || "").toUpperCase();
    // Enhanced check for contentEditable (like your notes or element names)
    const typingField = tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || !!t?.isContentEditable;

    if (typingField) {
      if (e.key === "Escape") { closeDrawer(); closeTimelineEditor(); }
      return; // This stops the timer from starting/stopping while you type
    }
    
    if (e.code === "Space") { 
      e.preventDefault(); 
      if (!$("mainBtn").disabled) $("mainBtn").click(); 
    }
    if (e.code === "Backspace") { if (!$("undoBtn").disabled) $("undoBtn").click(); }
    if (e.key === "Escape") { closeDrawer(); closeTimelineEditor(); }
  });

  // ----- renderAll -----
  function renderAll() {
    applyUiLayout();
    renderStationJobSidebar();
    renderTimelineScopeSelectors();
    renderJobConfigDrawer();
    renderHeaderKpisTimerGraph();
    renderVideoMarkersList();
    syncVideoTimeline();
  }

  function syncStateFromStorageIfChanged() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw || raw === lastStateSignature) return;
    try {
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.stations) || !Array.isArray(parsed.jobs)) return;
      state = loadState();
      lastStateSignature = raw;
      renderAll();
      flashSavePill("↻ Synced");
    } catch {}
  }

  // init
  window.addEventListener("storage", (e) => {
    if (e.key === STORAGE_KEY) syncStateFromStorageIfChanged();
    if (e.key === VIDEO_BOOKMARKS_KEY) populateVideoLibrarySelector();
  });
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
      syncStateFromStorageIfChanged();
      populateVideoLibrarySelector();
    }
  });
  initI18n().finally(() => {
    renderAll();
    applyI18nStatic();
  });

})();
</script>
</body>
</html>
